{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subject_1 = require('../Subject');\n\nvar Subscription_1 = require('../Subscription');\n\nvar tryCatch_1 = require('../util/tryCatch');\n\nvar errorObject_1 = require('../util/errorObject');\n\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowToggle.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var result = clicks.windowToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * ).mergeAll();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits (either `next` or `complete`), signals that the\n * associated window should complete.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowToggle\n * @owner Observable\n */\n\n\nfunction windowToggle(openings, closingSelector) {\n  return function (source) {\n    return source.lift(new WindowToggleOperator(openings, closingSelector));\n  };\n}\n\nexports.windowToggle = windowToggle;\n\nvar WindowToggleOperator = function () {\n  function WindowToggleOperator(openings, closingSelector) {\n    this.openings = openings;\n    this.closingSelector = closingSelector;\n  }\n\n  WindowToggleOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));\n  };\n\n  return WindowToggleOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar WindowToggleSubscriber = function (_super) {\n  __extends(WindowToggleSubscriber, _super);\n\n  function WindowToggleSubscriber(destination, openings, closingSelector) {\n    _super.call(this, destination);\n\n    this.openings = openings;\n    this.closingSelector = closingSelector;\n    this.contexts = [];\n    this.add(this.openSubscription = subscribeToResult_1.subscribeToResult(this, openings, openings));\n  }\n\n  WindowToggleSubscriber.prototype._next = function (value) {\n    var contexts = this.contexts;\n\n    if (contexts) {\n      var len = contexts.length;\n\n      for (var i = 0; i < len; i++) {\n        contexts[i].window.next(value);\n      }\n    }\n  };\n\n  WindowToggleSubscriber.prototype._error = function (err) {\n    var contexts = this.contexts;\n    this.contexts = null;\n\n    if (contexts) {\n      var len = contexts.length;\n      var index = -1;\n\n      while (++index < len) {\n        var context = contexts[index];\n        context.window.error(err);\n        context.subscription.unsubscribe();\n      }\n    }\n\n    _super.prototype._error.call(this, err);\n  };\n\n  WindowToggleSubscriber.prototype._complete = function () {\n    var contexts = this.contexts;\n    this.contexts = null;\n\n    if (contexts) {\n      var len = contexts.length;\n      var index = -1;\n\n      while (++index < len) {\n        var context = contexts[index];\n        context.window.complete();\n        context.subscription.unsubscribe();\n      }\n    }\n\n    _super.prototype._complete.call(this);\n  };\n  /** @deprecated internal use only */\n\n\n  WindowToggleSubscriber.prototype._unsubscribe = function () {\n    var contexts = this.contexts;\n    this.contexts = null;\n\n    if (contexts) {\n      var len = contexts.length;\n      var index = -1;\n\n      while (++index < len) {\n        var context = contexts[index];\n        context.window.unsubscribe();\n        context.subscription.unsubscribe();\n      }\n    }\n  };\n\n  WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    if (outerValue === this.openings) {\n      var closingSelector = this.closingSelector;\n      var closingNotifier = tryCatch_1.tryCatch(closingSelector)(innerValue);\n\n      if (closingNotifier === errorObject_1.errorObject) {\n        return this.error(errorObject_1.errorObject.e);\n      } else {\n        var window_1 = new Subject_1.Subject();\n        var subscription = new Subscription_1.Subscription();\n        var context = {\n          window: window_1,\n          subscription: subscription\n        };\n        this.contexts.push(context);\n        var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n\n        if (innerSubscription.closed) {\n          this.closeWindow(this.contexts.length - 1);\n        } else {\n          innerSubscription.context = context;\n          subscription.add(innerSubscription);\n        }\n\n        this.destination.next(window_1);\n      }\n    } else {\n      this.closeWindow(this.contexts.indexOf(outerValue));\n    }\n  };\n\n  WindowToggleSubscriber.prototype.notifyError = function (err) {\n    this.error(err);\n  };\n\n  WindowToggleSubscriber.prototype.notifyComplete = function (inner) {\n    if (inner !== this.openSubscription) {\n      this.closeWindow(this.contexts.indexOf(inner.context));\n    }\n  };\n\n  WindowToggleSubscriber.prototype.closeWindow = function (index) {\n    if (index === -1) {\n      return;\n    }\n\n    var contexts = this.contexts;\n    var context = contexts[index];\n    var window = context.window,\n        subscription = context.subscription;\n    contexts.splice(index, 1);\n    window.complete();\n    subscription.unsubscribe();\n  };\n\n  return WindowToggleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber); //# sourceMappingURL=windowToggle.js.map","map":{"version":3,"sources":["/Users/nguyenlong/Project/BirdNest/client-website-BirdNest/node_modules/ng5-slider/node_modules/rxjs/operators/windowToggle.js"],"names":["__extends","d","b","p","hasOwnProperty","__","constructor","prototype","Object","create","Subject_1","require","Subscription_1","tryCatch_1","errorObject_1","OuterSubscriber_1","subscribeToResult_1","windowToggle","openings","closingSelector","source","lift","WindowToggleOperator","exports","call","subscriber","subscribe","WindowToggleSubscriber","_super","destination","contexts","add","openSubscription","subscribeToResult","_next","value","len","length","i","window","next","_error","err","index","context","error","subscription","unsubscribe","_complete","complete","_unsubscribe","notifyNext","outerValue","innerValue","outerIndex","innerIndex","innerSub","closingNotifier","tryCatch","errorObject","e","window_1","Subject","Subscription","push","innerSubscription","closed","closeWindow","indexOf","notifyError","notifyComplete","inner","splice","OuterSubscriber"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar Subscription_1 = require('../Subscription');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowToggle.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var result = clicks.windowToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * ).mergeAll();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits (either `next` or `complete`), signals that the\n * associated window should complete.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowToggle\n * @owner Observable\n */\nfunction windowToggle(openings, closingSelector) {\n    return function (source) { return source.lift(new WindowToggleOperator(openings, closingSelector)); };\n}\nexports.windowToggle = windowToggle;\nvar WindowToggleOperator = (function () {\n    function WindowToggleOperator(openings, closingSelector) {\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n    }\n    WindowToggleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));\n    };\n    return WindowToggleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowToggleSubscriber = (function (_super) {\n    __extends(WindowToggleSubscriber, _super);\n    function WindowToggleSubscriber(destination, openings, closingSelector) {\n        _super.call(this, destination);\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n        this.contexts = [];\n        this.add(this.openSubscription = subscribeToResult_1.subscribeToResult(this, openings, openings));\n    }\n    WindowToggleSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        if (contexts) {\n            var len = contexts.length;\n            for (var i = 0; i < len; i++) {\n                contexts[i].window.next(value);\n            }\n        }\n    };\n    WindowToggleSubscriber.prototype._error = function (err) {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.error(err);\n                context.subscription.unsubscribe();\n            }\n        }\n        _super.prototype._error.call(this, err);\n    };\n    WindowToggleSubscriber.prototype._complete = function () {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.complete();\n                context.subscription.unsubscribe();\n            }\n        }\n        _super.prototype._complete.call(this);\n    };\n    /** @deprecated internal use only */ WindowToggleSubscriber.prototype._unsubscribe = function () {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.unsubscribe();\n                context.subscription.unsubscribe();\n            }\n        }\n    };\n    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (outerValue === this.openings) {\n            var closingSelector = this.closingSelector;\n            var closingNotifier = tryCatch_1.tryCatch(closingSelector)(innerValue);\n            if (closingNotifier === errorObject_1.errorObject) {\n                return this.error(errorObject_1.errorObject.e);\n            }\n            else {\n                var window_1 = new Subject_1.Subject();\n                var subscription = new Subscription_1.Subscription();\n                var context = { window: window_1, subscription: subscription };\n                this.contexts.push(context);\n                var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n                if (innerSubscription.closed) {\n                    this.closeWindow(this.contexts.length - 1);\n                }\n                else {\n                    innerSubscription.context = context;\n                    subscription.add(innerSubscription);\n                }\n                this.destination.next(window_1);\n            }\n        }\n        else {\n            this.closeWindow(this.contexts.indexOf(outerValue));\n        }\n    };\n    WindowToggleSubscriber.prototype.notifyError = function (err) {\n        this.error(err);\n    };\n    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {\n        if (inner !== this.openSubscription) {\n            this.closeWindow(this.contexts.indexOf(inner.context));\n        }\n    };\n    WindowToggleSubscriber.prototype.closeWindow = function (index) {\n        if (index === -1) {\n            return;\n        }\n        var contexts = this.contexts;\n        var context = contexts[index];\n        var window = context.window, subscription = context.subscription;\n        contexts.splice(index, 1);\n        window.complete();\n        subscription.unsubscribe();\n    };\n    return WindowToggleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=windowToggle.js.map"]},"metadata":{},"sourceType":"script"}