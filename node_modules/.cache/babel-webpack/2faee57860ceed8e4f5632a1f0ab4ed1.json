{"ast":null,"code":"import _classCallCheck from \"/Users/nguyenlong/ProjectCompany/2nMart/websiteclient-2nmart.vn/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/nguyenlong/ProjectCompany/2nMart/websiteclient-2nmart.vn/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"/Users/nguyenlong/ProjectCompany/2nMart/websiteclient-2nmart.vn/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport { Injectable, NgZone, RendererFactory2, Inject, PLATFORM_ID, ElementRef } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Subject, merge, fromEvent, of, animationFrameScheduler } from 'rxjs';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Get CSS computed property of the given element\n * @param {?} element\n * @param {?=} property\n * @return {?}\n */\n\nimport * as Éµngcc0 from '@angular/core';\n\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  } // NOTE: 1 DOM access here\n\n  /** @type {?} */\n\n\n  var window = element.ownerDocument.defaultView;\n  /** @type {?} */\n\n  var css = window.getComputedStyle(element, null);\n  return property ? css[\n  /** @type {?} */\n  property] : css;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Returns the parentNode or the host of the element\n * @param {?} element\n * @return {?}\n */\n\n\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n\n  return element.parentNode || element.host;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} element\n * @return {?}\n */\n\n\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n\n    case '#document':\n      return element.body;\n\n    default:\n  } // Firefox want us to check `-x` and `-y` variations as well\n\n\n  var _getStyleComputedProp = getStyleComputedProperty(element),\n      overflow = _getStyleComputedProp.overflow,\n      overflowX = _getStyleComputedProp.overflowX,\n      overflowY = _getStyleComputedProp.overflowY;\n\n  if (/(auto|scroll|overlay)/.test(String(overflow) + String(overflowY) + String(overflowX))) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\nvar isIE11 = isBrowser && !!(\n/** @type {?} */\nwindow.MSInputMethodContext &&\n/** @type {?} */\ndocument.documentMode);\n/** @type {?} */\n\nvar isIE10 = isBrowser && !!(\n/** @type {?} */\nwindow.MSInputMethodContext && /MSIE 10/.test(\n/** @type {?} */\nnavigator.userAgent));\n/**\n * @param {?=} version\n * @return {?}\n */\n\nfunction isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n\n  if (version === 10) {\n    return isIE10;\n  }\n\n  return isIE11 || isIE10;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} element\n * @return {?}\n */\n\n\nfunction getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n  }\n  /** @type {?} */\n\n\n  var noOffsetParent = isIE(10) ? document.body : null; // NOTE: 1 DOM access here\n\n  /** @type {?} */\n\n  var offsetParent = element.offsetParent || null; // Skip hidden elements which don't have an offsetParent\n\n  /** @type {?} */\n\n  var sibling;\n\n  while (offsetParent === noOffsetParent && element.nextElementSibling && sibling !== element.nextElementSibling) {\n    sibling = element.nextElementSibling;\n    offsetParent = sibling.offsetParent;\n  }\n  /** @type {?} */\n\n\n  var nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return sibling ? sibling.ownerDocument.documentElement : document.documentElement;\n  } // .offsetParent will return the closest TH, TD or TABLE in case\n\n\n  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} element\n * @return {?}\n */\n\n\nfunction isOffsetContainer(element) {\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY') {\n    return false;\n  }\n\n  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @param {?} node\n * @return {?}\n */\n\n\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} element1\n * @param {?} element2\n * @return {?}\n */\n\n\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  } // Here we make sure to give as \"start\" the element that comes first in the DOM\n\n  /* tslint:disable-next-line: no-bitwise */\n\n  /** @type {?} */\n\n\n  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  /** @type {?} */\n\n  var start = order ? element1 : element2;\n  /** @type {?} */\n\n  var end = order ? element2 : element1; // Get common ancestor container\n\n  /** @type {?} */\n\n  var range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  var commonAncestorContainer = range.commonAncestorContainer; // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  } // one of the nodes is inside shadowDOM, find which one\n\n  /** @type {?} */\n\n\n  var element1root = getRoot(element1);\n\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Helper to detect borders of a given element\n */\n\n/**\n * @param {?} styles\n * @param {?} axis\n * @return {?}\n */\n\n\nfunction getBordersSize(styles, axis) {\n  /** @type {?} */\n  var sideA = axis === 'x' ? 'Left' : 'Top';\n  /** @type {?} */\n\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n  return parseFloat(styles[\n  /** @type {?} */\n  \"border\".concat(sideA, \"Width\")]) + parseFloat(styles[\n  /** @type {?} */\n  \"border\".concat(sideB, \"Width\")]);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} axis\n * @param {?} body\n * @param {?} html\n * @param {?} computedStyle\n * @return {?}\n */\n\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(\n  /** @type {?} */\n  body[\"offset\".concat(axis)],\n  /** @type {?} */\n  body[\"scroll\".concat(axis)],\n  /** @type {?} */\n  html[\"client\".concat(axis)],\n  /** @type {?} */\n  html[\"offset\".concat(axis)],\n  /** @type {?} */\n  html[\"scroll\".concat(axis)], isIE(10) ? parseInt(\n  /** @type {?} */\n  html[\"offset\".concat(axis)], 10) + parseInt(computedStyle[\n  /** @type {?} */\n  \"margin\".concat(axis === 'Height' ? 'Top' : 'Left')], 10) + parseInt(computedStyle[\n  /** @type {?} */\n  \"margin\".concat(axis === 'Height' ? 'Bottom' : 'Right')], 10) : 0);\n}\n/**\n * @param {?} document\n * @return {?}\n */\n\n\nfunction getWindowSizes(document) {\n  /** @type {?} */\n  var body = document.body;\n  /** @type {?} */\n\n  var html = document.documentElement;\n  /** @type {?} */\n\n  var computedStyle = isIE(10) && getComputedStyle(html);\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @param {?} element\n * @param {?=} side\n * @return {?}\n */\n\n\nfunction getScroll(element) {\n  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n  /** @type {?} */\n  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  /** @type {?} */\n\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    /** @type {?} */\n    var html = element.ownerDocument.documentElement;\n    /** @type {?} */\n\n    var scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} offsets\n * @return {?}\n */\n\n\nfunction getClientRect(offsets) {\n  return Object.assign(Object.assign({}, offsets), {\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  });\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} element\n * @return {?}\n */\n\n\nfunction getBoundingClientRect(element) {\n  /** @type {?} */\n  var rect = {}; // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      /** @type {?} */\n\n      var scrollTop = getScroll(element, 'top');\n      /** @type {?} */\n\n      var scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n    }\n  } catch (e) {\n    return undefined;\n  }\n  /** @type {?} */\n\n\n  var result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  }; // subtract scrollbar size from sizes\n\n  /** @type {?} */\n\n  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n  /** @type {?} */\n\n  var width = sizes.width || element.clientWidth || result.right - result.left;\n  /** @type {?} */\n\n  var height = sizes.height || element.clientHeight || result.bottom - result.top;\n  /** @type {?} */\n\n  var horizScrollbar = element.offsetWidth - width;\n  /** @type {?} */\n\n  var vertScrollbar = element.offsetHeight - height; // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n\n  if (horizScrollbar || vertScrollbar) {\n    /** @type {?} */\n    var styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} rect\n * @param {?} element\n * @param {?=} subtract\n * @return {?}\n */\n\n\nfunction includeScroll(rect, element) {\n  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  /** @type {?} */\n  var scrollTop = getScroll(element, 'top');\n  /** @type {?} */\n\n  var scrollLeft = getScroll(element, 'left');\n  /** @type {?} */\n\n  var modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} children\n * @param {?} parent\n * @param {?=} fixedPosition\n * @return {?}\n */\n\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent) {\n  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  /** @type {?} */\n  var isIE10 = isIE(10);\n  /** @type {?} */\n\n  var isHTML = parent.nodeName === 'HTML';\n  /** @type {?} */\n\n  var childrenRect = getBoundingClientRect(children);\n  /** @type {?} */\n\n  var parentRect = getBoundingClientRect(parent);\n  /** @type {?} */\n\n  var scrollParent = getScrollParent(children);\n  /** @type {?} */\n\n  var styles = getStyleComputedProperty(parent);\n  /** @type {?} */\n\n  var borderTopWidth = parseFloat(styles.borderTopWidth);\n  /** @type {?} */\n\n  var borderLeftWidth = parseFloat(styles.borderLeftWidth); // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n\n  if (fixedPosition && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n  /** @type {?} */\n\n\n  var offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0; // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n\n  if (!isIE10 && isHTML) {\n    /** @type {?} */\n    var marginTop = parseFloat(styles.marginTop);\n    /** @type {?} */\n\n    var marginLeft = parseFloat(styles.marginLeft);\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft; // Attach marginTop and marginLeft because in some circumstances we may need them\n\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} element\n * @param {?=} excludeScroll\n * @return {?}\n */\n\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element) {\n  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  /** @type {?} */\n  var html = element.ownerDocument.documentElement;\n  /** @type {?} */\n\n  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  /** @type {?} */\n\n  var width = Math.max(html.clientWidth, window.innerWidth || 0);\n  /** @type {?} */\n\n  var height = Math.max(html.clientHeight, window.innerHeight || 0);\n  /** @type {?} */\n\n  var scrollTop = !excludeScroll ? getScroll(html) : 0;\n  /** @type {?} */\n\n  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n  /** @type {?} */\n\n  var offset = {\n    top: scrollTop - Number(relativeOffset.top) + Number(relativeOffset.marginTop),\n    left: scrollLeft - Number(relativeOffset.left) + Number(relativeOffset.marginLeft),\n    width: width,\n    height: height\n  };\n  return getClientRect(offset);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} element\n * @return {?}\n */\n\n\nfunction isFixed(element) {\n  /** @type {?} */\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n\n  return isFixed(getParentNode(element));\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} element\n * @return {?}\n */\n\n\nfunction getFixedPositionOffsetParent(element) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  /** @type {?} */\n\n\n  var el = element.parentElement;\n\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n\n  return el || document.documentElement;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} target\n * @param {?} host\n * @param {?=} padding\n * @param {?=} boundariesElement\n * @param {?=} fixedPosition\n * @return {?}\n */\n\n\nfunction getBoundaries(target, host) {\n  var padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var boundariesElement = arguments.length > 3 ? arguments[3] : undefined;\n  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  // NOTE: 1 DOM access here\n  // NOTE: 1 DOM access here\n\n  /** @type {?} */\n  var boundaries = {\n    top: 0,\n    left: 0\n  };\n  /** @type {?} */\n\n  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host); // Handle viewport case\n\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n\n    /** @type {?} */\n    var boundariesNode;\n\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(host));\n\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = target.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = target.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n    /** @type {?} */\n\n\n    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition); // In case of HTML, we need a different computation\n\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      var _getWindowSizes = getWindowSizes(target.ownerDocument),\n          height = _getWindowSizes.height,\n          width = _getWindowSizes.width;\n\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = Number(height) + Number(offsets.top);\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = Number(width) + Number(offsets.left);\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  } // Add paddings\n\n\n  boundaries.left += padding;\n  boundaries.top += padding;\n  boundaries.right -= padding;\n  boundaries.bottom -= padding;\n  return boundaries;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} __0\n * @return {?}\n */\n\n\nfunction getArea(_ref) {\n  var width = _ref.width,\n      height = _ref.height;\n  return width * height;\n}\n/**\n * @param {?} placement\n * @param {?} refRect\n * @param {?} target\n * @param {?} host\n * @param {?=} allowedPositions\n * @param {?=} boundariesElement\n * @param {?=} padding\n * @return {?}\n */\n\n\nfunction computeAutoPlacement(placement, refRect, target, host) {\n  var allowedPositions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ['top', 'bottom', 'right', 'left'];\n  var boundariesElement = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'viewport';\n  var padding = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n  /** @type {?} */\n\n\n  var boundaries = getBoundaries(target, host, padding, boundariesElement);\n  /** @type {?} */\n\n  var rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n  /** @type {?} */\n\n  var sortedAreas = Object.keys(rects).map(\n  /**\n  * @param {?} key\n  * @return {?}\n  */\n  function (key) {\n    return Object.assign(Object.assign({\n      key: key\n    }, rects[key]), {\n      area: getArea(rects[key])\n    });\n  }).sort(\n  /**\n  * @param {?} a\n  * @param {?} b\n  * @return {?}\n  */\n  function (a, b) {\n    return b.area - a.area;\n  });\n  /** @type {?} */\n\n  var filteredAreas = sortedAreas.filter(\n  /**\n  * @param {?} __0\n  * @return {?}\n  */\n  function (_ref2) {\n    var width = _ref2.width,\n        height = _ref2.height;\n    return width >= target.clientWidth && height >= target.clientHeight;\n  });\n  filteredAreas = filteredAreas.filter(\n  /**\n  * @param {?} position\n  * @return {?}\n  */\n  function (position) {\n    return allowedPositions.some(\n    /**\n    * @param {?} allowedPosition\n    * @return {?}\n    */\n    function (allowedPosition) {\n      return allowedPosition === position.key;\n    });\n  });\n  /** @type {?} */\n\n  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n  /** @type {?} */\n\n  var variation = placement.split(' ')[1]; // for tooltip on auto position\n\n  target.className = target.className.replace(/bs-tooltip-auto/g, \"bs-tooltip-\".concat(computedPlacement));\n  return computedPlacement + (variation ? \"-\".concat(variation) : '');\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} data\n * @return {?}\n */\n\n\nfunction getOffsets(data) {\n  return {\n    width: data.offsets.target.width,\n    height: data.offsets.target.height,\n    left: Math.floor(data.offsets.target.left),\n    top: Math.round(data.offsets.target.top),\n    bottom: Math.round(data.offsets.target.bottom),\n    right: Math.floor(data.offsets.target.right)\n  };\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Get the opposite placement of the given one\n * @param {?} placement\n * @return {?}\n */\n\n\nfunction getOppositePlacement(placement) {\n  /** @type {?} */\n  var hash = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n  return placement.replace(/left|right|bottom|top/g,\n  /**\n  * @param {?} matched\n  * @return {?}\n  */\n  function (matched) {\n    return (\n      /** @type {?} */\n      hash[matched]\n    );\n  });\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Get the opposite placement variation of the given one\n * @param {?} variation\n * @return {?}\n */\n\n\nfunction getOppositeVariation(variation) {\n  if (variation === 'right') {\n    return 'left';\n  } else if (variation === 'left') {\n    return 'right';\n  }\n\n  return variation;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @param {?} element\n * @return {?}\n */\n\n\nfunction getOuterSizes(element) {\n  /** @type {?} */\n  var window = element.ownerDocument.defaultView;\n  /** @type {?} */\n\n  var styles = window.getComputedStyle(element);\n  /** @type {?} */\n\n  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  /** @type {?} */\n\n  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n  return {\n    width: Number(element.offsetWidth) + y,\n    height: Number(element.offsetHeight) + x\n  };\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} target\n * @param {?} host\n * @param {?=} fixedPosition\n * @return {?}\n */\n\n\nfunction getReferenceOffsets(target, host) {\n  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  /** @type {?} */\n  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host);\n  return getOffsetRectRelativeToArbitraryNode(host, commonOffsetParent, fixedPosition);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} target\n * @param {?} hostOffsets\n * @param {?} position\n * @return {?}\n */\n\n\nfunction getTargetOffsets(target, hostOffsets, position) {\n  /** @type {?} */\n  var placement = position.split(' ')[0]; // Get target node sizes\n\n  /** @type {?} */\n\n  var targetRect = getOuterSizes(target); // Add position, width and height to our offsets object\n\n  /** @type {?} */\n\n  var targetOffsets = {\n    width: targetRect.width,\n    height: targetRect.height\n  }; // depending by the target placement we have to compute its offsets slightly differently\n\n  /** @type {?} */\n\n  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  /** @type {?} */\n\n  var mainSide = isHoriz ? 'top' : 'left';\n  /** @type {?} */\n\n  var secondarySide = isHoriz ? 'left' : 'top';\n  /** @type {?} */\n\n  var measurement = isHoriz ? 'height' : 'width';\n  /** @type {?} */\n\n  var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  /** @type {?} */\n  targetOffsets[mainSide] = hostOffsets[mainSide] + hostOffsets[measurement] / 2 - targetRect[measurement] / 2;\n\n  /** @type {?} */\n  targetOffsets[secondarySide] = placement === secondarySide ? hostOffsets[secondarySide] - targetRect[secondaryMeasurement] :\n  /** @type {?} */\n  hostOffsets[getOppositePlacement(secondarySide)];\n  return targetOffsets;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Helper used to know if the given modifier is enabled.\n * @param {?} options\n * @param {?} modifierName\n * @return {?}\n */\n\n\nfunction isModifierEnabled(options, modifierName) {\n  return options && options.modifiers && options.modifiers[modifierName] && options.modifiers[modifierName].enabled;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Tells if a given input is a number\n * @param {?} n\n * @return {?}\n */\n\n\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} data\n * @param {?=} renderer\n * @return {?}\n */\n\n\nfunction updateContainerClass(data, renderer) {\n  /** @type {?} */\n  var target = data.instance.target;\n  /** @type {?} */\n\n  var containerClass = target.className;\n\n  if (data.placementAuto) {\n    containerClass = containerClass.replace(/bs-popover-auto/g, \"bs-popover-\".concat(data.placement));\n    containerClass = containerClass.replace(/bs-tooltip-auto/g, \"bs-tooltip-\".concat(data.placement));\n    containerClass = containerClass.replace(/\\sauto/g, \" \".concat(data.placement));\n\n    if (containerClass.indexOf('popover') !== -1 && containerClass.indexOf('popover-auto') === -1) {\n      containerClass += ' popover-auto';\n    }\n\n    if (containerClass.indexOf('tooltip') !== -1 && containerClass.indexOf('tooltip-auto') === -1) {\n      containerClass += ' tooltip-auto';\n    }\n  }\n\n  containerClass = containerClass.replace(/left|right|top|bottom/g, \"\".concat(data.placement.split(' ')[0]));\n\n  if (renderer) {\n    renderer.setAttribute(target, 'class', containerClass);\n    return;\n  }\n\n  target.className = containerClass;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} element\n * @param {?} styles\n * @param {?=} renderer\n * @return {?}\n */\n\n\nfunction setStyles(element, styles, renderer) {\n  Object.keys(styles).forEach(\n  /**\n  * @param {?} prop\n  * @return {?}\n  */\n  function (prop) {\n    /** @type {?} */\n    var unit = ''; // add unit if the value is numeric and is one of the following\n\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n\n    if (renderer) {\n      renderer.setStyle(element, prop, \"\".concat(String(styles[prop])).concat(unit));\n      return;\n    }\n\n    element.style[prop] = String(styles[prop]) + unit;\n  });\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} data\n * @return {?}\n */\n\n\nfunction arrow(data) {\n  /** @type {?} */\n  var targetOffsets = data.offsets.target; // if arrowElement is a string, suppose it's a CSS selector\n\n  /** @type {?} */\n\n  var arrowElement = data.instance.target.querySelector('.arrow'); // if arrowElement is not found, don't run the modifier\n\n  if (!arrowElement) {\n    return data;\n  }\n  /** @type {?} */\n\n\n  var isVertical = ['left', 'right'].indexOf(data.placement.split(' ')[0]) !== -1;\n  /** @type {?} */\n\n  var len = isVertical ? 'height' : 'width';\n  /** @type {?} */\n\n  var sideCapitalized = isVertical ? 'Top' : 'Left';\n  /** @type {?} */\n\n  var side = sideCapitalized.toLowerCase();\n  /** @type {?} */\n\n  var altSide = isVertical ? 'left' : 'top';\n  /** @type {?} */\n\n  var opSide = isVertical ? 'bottom' : 'right';\n  /** @type {?} */\n\n  var arrowElementSize = getOuterSizes(arrowElement)[len];\n  /** @type {?} */\n\n  var placementVariation = data.placement.split(' ')[1]; // top/left side\n\n  if (data.offsets.host[opSide] - arrowElementSize <\n  /** @type {?} */\n  targetOffsets[side]) {\n    /** @type {?} */\n    targetOffsets[side] -=\n    /** @type {?} */\n    targetOffsets[side] - (data.offsets.host[opSide] - arrowElementSize);\n  } // bottom/right side\n\n\n  if (Number(\n  /** @type {?} */\n  data.offsets.host[side]) + Number(arrowElementSize) >\n  /** @type {?} */\n  targetOffsets[opSide]) {\n    /** @type {?} */\n    targetOffsets[side] += Number(\n    /** @type {?} */\n    data.offsets.host[side]) + Number(arrowElementSize) - Number(\n    /** @type {?} */\n    targetOffsets[opSide]);\n  }\n\n  targetOffsets = getClientRect(targetOffsets); // Compute the sideValue using the updated target offsets\n  // take target margin in account because we don't have this info available\n\n  /** @type {?} */\n\n  var css = getStyleComputedProperty(data.instance.target);\n  /** @type {?} */\n\n  var targetMarginSide = parseFloat(css[\"margin\".concat(sideCapitalized)]);\n  /** @type {?} */\n\n  var targetBorderSide = parseFloat(css[\"border\".concat(sideCapitalized, \"Width\")]); // compute center of the target\n\n  /** @type {?} */\n\n  var center;\n\n  if (!placementVariation) {\n    center = Number(\n    /** @type {?} */\n    data.offsets.host[side]) + Number(data.offsets.host[len] / 2 - arrowElementSize / 2);\n  } else {\n    /** @type {?} */\n    var targetBorderRadius = parseFloat(css.borderRadius);\n    /** @type {?} */\n\n    var targetSideArrowOffset = Number(targetMarginSide + targetBorderSide + targetBorderRadius);\n    center = side === placementVariation ? Number(\n    /** @type {?} */\n    data.offsets.host[side]) + targetSideArrowOffset : Number(\n    /** @type {?} */\n    data.offsets.host[side]) + Number(data.offsets.host[len] - targetSideArrowOffset);\n  }\n  /** @type {?} */\n\n\n  var sideValue = center -\n  /** @type {?} */\n  targetOffsets[side] - targetMarginSide - targetBorderSide; // prevent arrowElement from being placed not contiguously to its target\n\n  sideValue = Math.max(Math.min(targetOffsets[len] - arrowElementSize, sideValue), 0);\n  data.offsets.arrow = _defineProperty(_defineProperty({}, side, Math.round(sideValue)), altSide, '');\n  data.instance.arrow = arrowElement;\n  return data;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} data\n * @return {?}\n */\n\n\nfunction flip(data) {\n  data.offsets.target = getClientRect(data.offsets.target);\n\n  if (!isModifierEnabled(data.options, 'flip')) {\n    data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), getTargetOffsets(data.instance.target, data.offsets.host, data.placement));\n    return data;\n  }\n  /** @type {?} */\n\n\n  var boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n  'viewport', false // positionFixed\n  );\n  /** @type {?} */\n\n  var placement = data.placement.split(' ')[0];\n  /** @type {?} */\n\n  var variation = data.placement.split(' ')[1] || '';\n  /** @type {?} */\n\n  var offsetsHost = data.offsets.host;\n  /** @type {?} */\n\n  var target = data.instance.target;\n  /** @type {?} */\n\n  var host = data.instance.host;\n  /** @type {?} */\n\n  var adaptivePosition = computeAutoPlacement('auto', offsetsHost, target, host, data.options.allowedPositions);\n  /** @type {?} */\n\n  var flipOrder = [placement, adaptivePosition];\n  /* tslint:disable-next-line: cyclomatic-complexity */\n\n  flipOrder.forEach(\n  /**\n  * @param {?} step\n  * @param {?} index\n  * @return {?}\n  */\n  function (step, index) {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split(' ')[0]; // using floor because the host offsets may contain decimals we are not going to consider here\n\n    /** @type {?} */\n\n    var overlapsRef = placement === 'left' && Math.floor(data.offsets.target.right) > Math.floor(data.offsets.host.left) || placement === 'right' && Math.floor(data.offsets.target.left) < Math.floor(data.offsets.host.right) || placement === 'top' && Math.floor(data.offsets.target.bottom) > Math.floor(data.offsets.host.top) || placement === 'bottom' && Math.floor(data.offsets.target.top) < Math.floor(data.offsets.host.bottom);\n    /** @type {?} */\n\n    var overflowsLeft = Math.floor(data.offsets.target.left) < Math.floor(boundaries.left);\n    /** @type {?} */\n\n    var overflowsRight = Math.floor(data.offsets.target.right) > Math.floor(boundaries.right);\n    /** @type {?} */\n\n    var overflowsTop = Math.floor(data.offsets.target.top) < Math.floor(boundaries.top);\n    /** @type {?} */\n\n    var overflowsBottom = Math.floor(data.offsets.target.bottom) > Math.floor(boundaries.bottom);\n    /** @type {?} */\n\n    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom; // flip the variation if required\n\n    /** @type {?} */\n\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    /** @type {?} */\n\n    var flippedVariation = isVertical && variation === 'left' && overflowsLeft || isVertical && variation === 'right' && overflowsRight || !isVertical && variation === 'left' && overflowsTop || !isVertical && variation === 'right' && overflowsBottom;\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? \" \".concat(variation) : '');\n      data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), getTargetOffsets(data.instance.target, data.offsets.host, data.placement));\n    }\n  });\n  return data;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} targetElement\n * @param {?} hostElement\n * @param {?} position\n * @param {?} options\n * @return {?}\n */\n\n\nfunction initData(targetElement, hostElement, position, options) {\n  /** @type {?} */\n  var hostElPosition = getReferenceOffsets(targetElement, hostElement);\n\n  if (!position.match(/^(auto)*\\s*(left|right|top|bottom)*$/) && !position.match(/^(left|right|top|bottom)*(?: (left|right|top|bottom))?\\s*(start|end)*$/)) {\n    /* tslint:disable-next-line: no-parameter-reassignment */\n    position = 'auto';\n  }\n  /** @type {?} */\n\n\n  var placementAuto = !!position.match(/auto/g); // support old placements 'auto left|right|top|bottom'\n\n  /** @type {?} */\n\n  var placement = position.match(/auto\\s(left|right|top|bottom)/) ? position.split(' ')[1] || 'auto' : position; // Normalize placements that have identical main placement and variation (\"right right\" => \"right\").\n\n  /** @type {?} */\n\n  var matches = placement.match(/^(left|right|top|bottom)* ?(?!\\1)(left|right|top|bottom)?/);\n\n  if (matches) {\n    placement = matches[1] + (matches[2] ? \" \".concat(matches[2]) : '');\n  } // \"left right\", \"top bottom\" etc. placements also considered incorrect.\n\n\n  if (['left right', 'right left', 'top bottom', 'bottom top'].indexOf(placement) !== -1) {\n    placement = 'auto';\n  }\n  /** @type {?} */\n\n\n  var targetOffset = getTargetOffsets(targetElement, hostElPosition, placement);\n  placement = computeAutoPlacement(placement, hostElPosition, targetElement, hostElement, options ? options.allowedPositions : undefined);\n  return {\n    options: options,\n    instance: {\n      target: targetElement,\n      host: hostElement,\n      arrow: null\n    },\n    offsets: {\n      target: targetOffset,\n      host: hostElPosition,\n      arrow: null\n    },\n    positionFixed: false,\n    placement: placement,\n    placementAuto: placementAuto\n  };\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} data\n * @return {?}\n */\n\n\nfunction preventOverflow(data) {\n  if (!isModifierEnabled(data.options, 'preventOverflow')) {\n    return data;\n  } // NOTE: DOM access here\n  // resets the targetOffsets's position so that the document size can be calculated excluding\n  // the size of the targetOffsets element itself\n\n  /** @type {?} */\n\n\n  var transformProp = 'transform';\n  /** @type {?} */\n\n  var targetStyles = data.instance.target.style; // assignment to help minification\n\n  var top = targetStyles.top,\n      left = targetStyles.left,\n      transform = targetStyles[transformProp];\n  targetStyles.top = '';\n  targetStyles.left = '';\n  targetStyles[transformProp] = '';\n  /** @type {?} */\n\n  var boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n  'scrollParent', false // positionFixed\n  ); // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n\n  targetStyles.top = top;\n  targetStyles.left = left;\n  targetStyles[transformProp] = transform;\n  /** @type {?} */\n\n  var order = ['left', 'right', 'top', 'bottom'];\n  /** @type {?} */\n\n  var check = {\n    /**\n     * @param {?} placement\n     * @return {?}\n     */\n    primary: function primary(placement) {\n      /** @type {?} */\n      var value =\n      /** @type {?} */\n      data.offsets.target[placement];\n\n      if (\n      /** @type {?} */\n      data.offsets.target[placement] < boundaries[placement] && !false // options.escapeWithReference\n      ) {\n        value = Math.max(\n        /** @type {?} */\n        data.offsets.target[placement], boundaries[placement]);\n      }\n\n      return _defineProperty({}, placement, value);\n    },\n\n    /**\n     * @param {?} placement\n     * @return {?}\n     */\n    secondary: function secondary(placement) {\n      /** @type {?} */\n      var mainSide = placement === 'right' ? 'left' : 'top';\n      /** @type {?} */\n\n      var value = data.offsets.target[mainSide];\n\n      if (\n      /** @type {?} */\n      data.offsets.target[placement] > boundaries[placement] && !false // escapeWithReference\n      ) {\n        value = Math.min(data.offsets.target[mainSide], boundaries[placement] - (placement === 'right' ? data.offsets.target.width : data.offsets.target.height));\n      }\n\n      return _defineProperty({}, mainSide, value);\n    }\n  };\n  /** @type {?} */\n\n  var side;\n  order.forEach(\n  /**\n  * @param {?} placement\n  * @return {?}\n  */\n  function (placement) {\n    side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n    data.offsets.target = Object.assign(Object.assign({}, data.offsets.target),\n    /** @type {?} */\n    check[side](placement));\n  });\n  return data;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} data\n * @return {?}\n */\n\n\nfunction shift(data) {\n  /** @type {?} */\n  var placement = data.placement;\n  /** @type {?} */\n\n  var basePlacement = placement.split(' ')[0];\n  /** @type {?} */\n\n  var shiftVariation = placement.split(' ')[1];\n\n  if (shiftVariation) {\n    var _data$offsets = data.offsets,\n        host = _data$offsets.host,\n        target = _data$offsets.target;\n    /** @type {?} */\n\n    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    /** @type {?} */\n\n    var side = isVertical ? 'left' : 'top';\n    /** @type {?} */\n\n    var measurement = isVertical ? 'width' : 'height';\n    /** @type {?} */\n\n    var shiftOffsets = {\n      start: _defineProperty({}, side, host[side]),\n      end: _defineProperty({}, side, host[side] + host[measurement] - target[measurement])\n    };\n    data.offsets.target = Object.assign(Object.assign({}, target), _defineProperty({}, side, side === shiftVariation ?\n    /** @type {?} */\n    shiftOffsets.start[side] :\n    /** @type {?} */\n    shiftOffsets.end[side]));\n  }\n\n  return data;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar Positioning = /*#__PURE__*/function () {\n  function Positioning() {\n    _classCallCheck(this, Positioning);\n  }\n\n  return _createClass(Positioning, [{\n    key: \"position\",\n    value:\n    /**\n     * @param {?} hostElement\n     * @param {?} targetElement\n     * @param {?=} round\n     * @return {?}\n     */\n    function position(hostElement, targetElement) {\n      var round = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      return this.offset(hostElement, targetElement, false);\n    }\n    /**\n     * @param {?} hostElement\n     * @param {?} targetElement\n     * @param {?=} round\n     * @return {?}\n     */\n\n  }, {\n    key: \"offset\",\n    value: function offset(hostElement, targetElement) {\n      var round = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      return getReferenceOffsets(targetElement, hostElement);\n    }\n    /**\n     * @param {?} hostElement\n     * @param {?} targetElement\n     * @param {?} position\n     * @param {?=} appendToBody\n     * @param {?=} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"positionElements\",\n    value: function positionElements(hostElement, targetElement, position, appendToBody, options) {\n      /** @type {?} */\n      var chainOfModifiers = [flip, shift, preventOverflow, arrow];\n      return chainOfModifiers.reduce(\n      /**\n      * @param {?} modifiedData\n      * @param {?} modifier\n      * @return {?}\n      */\n      function (modifiedData, modifier) {\n        return modifier(modifiedData);\n      }, initData(targetElement, hostElement, position, options));\n    }\n  }]);\n}();\n/** @type {?} */\n\n\nvar positionService = new Positioning();\n/**\n * @param {?} hostElement\n * @param {?} targetElement\n * @param {?} placement\n * @param {?=} appendToBody\n * @param {?=} options\n * @param {?=} renderer\n * @return {?}\n */\n\nfunction positionElements(hostElement, targetElement, placement, appendToBody, options, renderer) {\n  /** @type {?} */\n  var data = positionService.positionElements(hostElement, targetElement, placement, appendToBody, options);\n  /** @type {?} */\n\n  var offsets = getOffsets(data);\n  setStyles(targetElement, {\n    'will-change': 'transform',\n    top: '0px',\n    left: '0px',\n    transform: \"translate3d(\".concat(offsets.left, \"px, \").concat(offsets.top, \"px, 0px)\")\n  }, renderer);\n\n  if (data.instance.arrow) {\n    setStyles(data.instance.arrow, data.offsets.arrow, renderer);\n  }\n\n  updateContainerClass(data, renderer);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n\nfunction PositioningOptions() {}\n\nif (false) {\n  /**\n   * The DOM element, ElementRef, or a selector string of an element which will be moved\n   * @type {?|undefined}\n   */\n  PositioningOptions.prototype.element;\n  /**\n   * The DOM element, ElementRef, or a selector string of an element which the element will be attached to\n   * @type {?|undefined}\n   */\n\n  PositioningOptions.prototype.target;\n  /**\n   * A string of the form 'vert-attachment horiz-attachment' or 'placement'\n   * - placement can be \"top\", \"bottom\", \"left\", \"right\"\n   * not yet supported:\n   * - vert-attachment can be any of 'top', 'middle', 'bottom'\n   * - horiz-attachment can be any of 'left', 'center', 'right'\n   * @type {?|undefined}\n   */\n\n  PositioningOptions.prototype.attachment;\n  /**\n   * A string similar to `attachment`. The one difference is that, if it's not provided,\n   * `targetAttachment` will assume the mirror image of `attachment`.\n   * @type {?|undefined}\n   */\n\n  PositioningOptions.prototype.targetAttachment;\n  /**\n   * A string of the form 'vert-offset horiz-offset'\n   * - vert-offset and horiz-offset can be of the form \"20px\" or \"55%\"\n   * @type {?|undefined}\n   */\n\n  PositioningOptions.prototype.offset;\n  /**\n   * A string similar to `offset`, but referring to the offset of the target\n   * @type {?|undefined}\n   */\n\n  PositioningOptions.prototype.targetOffset;\n  /**\n   * If true component will be attached to body\n   * @type {?|undefined}\n   */\n\n  PositioningOptions.prototype.appendToBody;\n}\n\nvar PositioningService = /*#__PURE__*/function () {\n  /**\n   * @param {?} ngZone\n   * @param {?} rendererFactory\n   * @param {?} platformId\n   */\n  function PositioningService(ngZone, rendererFactory, platformId) {\n    var _this = this;\n\n    _classCallCheck(this, PositioningService);\n\n    this.update$$ = new Subject();\n    this.positionElements = new Map();\n    this.isDisabled = false;\n\n    if (isPlatformBrowser(platformId)) {\n      ngZone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      function () {\n        _this.triggerEvent$ = merge(fromEvent(window, 'scroll', {\n          passive: true\n        }), fromEvent(window, 'resize', {\n          passive: true\n        }),\n        /* tslint:disable-next-line: deprecation */\n        of(0, animationFrameScheduler), _this.update$$);\n\n        _this.triggerEvent$.subscribe(\n        /**\n        * @return {?}\n        */\n        function () {\n          if (_this.isDisabled) {\n            return;\n          }\n\n          _this.positionElements\n          /* tslint:disable-next-line: no-any */\n          .forEach(\n          /**\n          * @param {?} positionElement\n          * @return {?}\n          */\n          function (positionElement) {\n            positionElements(_getHtmlElement(positionElement.target), _getHtmlElement(positionElement.element), positionElement.attachment, positionElement.appendToBody, _this.options, rendererFactory.createRenderer(null, null));\n          });\n        });\n      });\n    }\n  }\n  /**\n   * @param {?} options\n   * @return {?}\n   */\n\n\n  return _createClass(PositioningService, [{\n    key: \"position\",\n    value: function position(options) {\n      this.addPositionElement(options);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"event$\",\n    get: function get() {\n      return this.triggerEvent$;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.isDisabled = true;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      this.isDisabled = false;\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"addPositionElement\",\n    value: function addPositionElement(options) {\n      this.positionElements.set(_getHtmlElement(options.element), options);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"calcPosition\",\n    value: function calcPosition() {\n      this.update$$.next();\n    }\n    /**\n     * @param {?} elRef\n     * @return {?}\n     */\n\n  }, {\n    key: \"deletePositionElement\",\n    value: function deletePositionElement(elRef) {\n      this.positionElements.delete(_getHtmlElement(elRef));\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n    }\n  }]);\n}();\n\nPositioningService.Éµfac = function PositioningService_Factory(t) {\n  return new (t || PositioningService)(Éµngcc0.ÉµÉµinject(Éµngcc0.NgZone), Éµngcc0.ÉµÉµinject(Éµngcc0.RendererFactory2), Éµngcc0.ÉµÉµinject(PLATFORM_ID));\n};\n\nPositioningService.Éµprov = Éµngcc0.ÉµÉµdefineInjectable({\n  token: PositioningService,\n  factory: PositioningService.Éµfac\n});\n/** @nocollapse */\n\nPositioningService.ctorParameters = function () {\n  return [{\n    type: NgZone\n  }, {\n    type: RendererFactory2\n  }, {\n    type: Number,\n    decorators: [{\n      type: Inject,\n      args: [PLATFORM_ID]\n    }]\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(PositioningService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: Éµngcc0.NgZone\n    }, {\n      type: Éµngcc0.RendererFactory2\n    }, {\n      type: Number,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  PositioningService.prototype.options;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  PositioningService.prototype.update$$;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  PositioningService.prototype.positionElements;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  PositioningService.prototype.triggerEvent$;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  PositioningService.prototype.isDisabled;\n}\n/**\n * @param {?} element\n * @return {?}\n */\n\n\nfunction _getHtmlElement(element) {\n  // it means that we got a selector\n  if (typeof element === 'string') {\n    return document.querySelector(element);\n  }\n\n  if (element instanceof ElementRef) {\n    return element.nativeElement;\n  }\n\n  return element;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { Positioning, PositioningService, positionElements }; //# sourceMappingURL=ngx-bootstrap-positioning.js.map","map":{"version":3,"sources":["/Users/nguyenlong/ProjectCompany/2nMart/websiteclient-2nmart.vn/node_modules/ngx-bootstrap/__ivy_ngcc__/positioning/fesm2015/ngx-bootstrap-positioning.js"],"names":["Injectable","NgZone","RendererFactory2","Inject","PLATFORM_ID","ElementRef","isPlatformBrowser","Subject","merge","fromEvent","of","animationFrameScheduler","Éµngcc0","getStyleComputedProperty","element","property","nodeType","window","ownerDocument","defaultView","css","getComputedStyle","getParentNode","nodeName","parentNode","host","getScrollParent","document","body","overflow","overflowX","overflowY","test","String","isBrowser","isIE11","MSInputMethodContext","documentMode","isIE10","navigator","userAgent","isIE","version","getOffsetParent","documentElement","noOffsetParent","offsetParent","sibling","nextElementSibling","indexOf","isOffsetContainer","firstElementChild","getRoot","node","findCommonOffsetParent","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","contains","element1root","getBordersSize","styles","axis","sideA","sideB","parseFloat","getSize","html","computedStyle","Math","max","parseInt","getWindowSizes","height","width","getScroll","side","upperSide","scrollingElement","getClientRect","offsets","Object","assign","right","left","bottom","top","getBoundingClientRect","rect","scrollTop","scrollLeft","e","undefined","result","sizes","clientWidth","clientHeight","horizScrollbar","offsetWidth","vertScrollbar","offsetHeight","includeScroll","subtract","modifier","getOffsetRectRelativeToArbitraryNode","children","parent","fixedPosition","isHTML","childrenRect","parentRect","scrollParent","borderTopWidth","borderLeftWidth","marginTop","marginLeft","getViewportOffsetRectRelativeToArtbitraryNode","excludeScroll","relativeOffset","innerWidth","innerHeight","offset","Number","isFixed","getFixedPositionOffsetParent","parentElement","el","getBoundaries","target","padding","boundariesElement","boundaries","boundariesNode","getArea","computeAutoPlacement","placement","refRect","allowedPositions","rects","sortedAreas","keys","map","key","area","sort","a","b","filteredAreas","filter","position","some","allowedPosition","computedPlacement","length","variation","split","className","replace","getOffsets","data","floor","round","getOppositePlacement","hash","matched","getOppositeVariation","getOuterSizes","x","marginBottom","y","marginRight","getReferenceOffsets","commonOffsetParent","getTargetOffsets","hostOffsets","targetRect","targetOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","isModifierEnabled","options","modifierName","modifiers","enabled","isNumeric","n","isNaN","isFinite","updateContainerClass","renderer","instance","containerClass","placementAuto","setAttribute","setStyles","forEach","prop","unit","setStyle","style","arrow","arrowElement","querySelector","isVertical","len","sideCapitalized","toLowerCase","altSide","opSide","arrowElementSize","placementVariation","targetMarginSide","targetBorderSide","center","targetBorderRadius","borderRadius","targetSideArrowOffset","sideValue","min","flip","offsetsHost","adaptivePosition","flipOrder","step","index","overlapsRef","overflowsLeft","overflowsRight","overflowsTop","overflowsBottom","overflowsBoundaries","flippedVariation","initData","targetElement","hostElement","hostElPosition","match","matches","targetOffset","positionFixed","preventOverflow","transformProp","targetStyles","transform","check","primary","value","secondary","shift","basePlacement","shiftVariation","shiftOffsets","Positioning","positionElements","appendToBody","chainOfModifiers","reduce","modifiedData","positionService","PositioningOptions","prototype","attachment","targetAttachment","PositioningService","ngZone","rendererFactory","platformId","update$$","Map","isDisabled","runOutsideAngular","triggerEvent$","passive","subscribe","positionElement","_getHtmlElement","createRenderer","addPositionElement","disable","enable","set","calcPosition","next","deletePositionElement","elRef","delete","setOptions","Éµfac","PositioningService_Factory","t","ÉµÉµinject","Éµprov","ÉµÉµdefineInjectable","token","factory","ctorParameters","type","decorators","args","ngDevMode","ÉµsetClassMetadata","nativeElement"],"mappings":"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","sourcesContent":["import { Injectable, NgZone, RendererFactory2, Inject, PLATFORM_ID, ElementRef } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Subject, merge, fromEvent, of, animationFrameScheduler } from 'rxjs';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Get CSS computed property of the given element\n * @param {?} element\n * @param {?=} property\n * @return {?}\n */\nimport * as Éµngcc0 from '@angular/core';\nfunction getStyleComputedProperty(element, property) {\n    if (element.nodeType !== 1) {\n        return [];\n    }\n    // NOTE: 1 DOM access here\n    /** @type {?} */\n    const window = element.ownerDocument.defaultView;\n    /** @type {?} */\n    const css = window.getComputedStyle(element, null);\n    return property ? css[(/** @type {?} */ (property))] : css;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Returns the parentNode or the host of the element\n * @param {?} element\n * @return {?}\n */\nfunction getParentNode(element) {\n    if (element.nodeName === 'HTML') {\n        return element;\n    }\n    return element.parentNode || element.host;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction getScrollParent(element) {\n    // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n    if (!element) {\n        return document.body;\n    }\n    switch (element.nodeName) {\n        case 'HTML':\n        case 'BODY':\n            return element.ownerDocument.body;\n        case '#document':\n            return element.body;\n        default:\n    }\n    // Firefox want us to check `-x` and `-y` variations as well\n    const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);\n    if (/(auto|scroll|overlay)/.test(String(overflow) + String(overflowY) + String(overflowX))) {\n        return element;\n    }\n    return getScrollParent(getParentNode(element));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst isIE11 = isBrowser && !!(((/** @type {?} */ (window))).MSInputMethodContext && ((/** @type {?} */ (document))).documentMode);\n/** @type {?} */\nconst isIE10 = isBrowser && !!(((/** @type {?} */ (window))).MSInputMethodContext && /MSIE 10/.test(((/** @type {?} */ (navigator))).userAgent));\n/**\n * @param {?=} version\n * @return {?}\n */\nfunction isIE(version) {\n    if (version === 11) {\n        return isIE11;\n    }\n    if (version === 10) {\n        return isIE10;\n    }\n    return isIE11 || isIE10;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction getOffsetParent(element) {\n    if (!element) {\n        return document.documentElement;\n    }\n    /** @type {?} */\n    const noOffsetParent = isIE(10) ? document.body : null;\n    // NOTE: 1 DOM access here\n    /** @type {?} */\n    let offsetParent = element.offsetParent || null;\n    // Skip hidden elements which don't have an offsetParent\n    /** @type {?} */\n    let sibling;\n    while (offsetParent === noOffsetParent\n        && element.nextElementSibling\n        && sibling !== element.nextElementSibling) {\n        sibling = element.nextElementSibling;\n        offsetParent = sibling.offsetParent;\n    }\n    /** @type {?} */\n    const nodeName = offsetParent && offsetParent.nodeName;\n    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n        return sibling ? sibling.ownerDocument.documentElement : document.documentElement;\n    }\n    // .offsetParent will return the closest TH, TD or TABLE in case\n    if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 &&\n        getStyleComputedProperty(offsetParent, 'position') === 'static') {\n        return getOffsetParent(offsetParent);\n    }\n    return offsetParent;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction isOffsetContainer(element) {\n    const { nodeName } = element;\n    if (nodeName === 'BODY') {\n        return false;\n    }\n    return (nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @param {?} node\n * @return {?}\n */\nfunction getRoot(node) {\n    if (node.parentNode !== null) {\n        return getRoot(node.parentNode);\n    }\n    return node;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element1\n * @param {?} element2\n * @return {?}\n */\nfunction findCommonOffsetParent(element1, element2) {\n    // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n        return document.documentElement;\n    }\n    // Here we make sure to give as \"start\" the element that comes first in the DOM\n    /* tslint:disable-next-line: no-bitwise */\n    /** @type {?} */\n    const order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n    /** @type {?} */\n    const start = order ? element1 : element2;\n    /** @type {?} */\n    const end = order ? element2 : element1;\n    // Get common ancestor container\n    /** @type {?} */\n    const range = document.createRange();\n    range.setStart(start, 0);\n    range.setEnd(end, 0);\n    const { commonAncestorContainer } = range;\n    // Both nodes are inside #document\n    if ((element1 !== commonAncestorContainer &&\n        element2 !== commonAncestorContainer) ||\n        start.contains(end)) {\n        if (isOffsetContainer(commonAncestorContainer)) {\n            return commonAncestorContainer;\n        }\n        return getOffsetParent(commonAncestorContainer);\n    }\n    // one of the nodes is inside shadowDOM, find which one\n    /** @type {?} */\n    const element1root = getRoot(element1);\n    if (element1root.host) {\n        return findCommonOffsetParent(element1root.host, element2);\n    }\n    else {\n        return findCommonOffsetParent(element1, getRoot(element2).host);\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Helper to detect borders of a given element\n */\n/**\n * @param {?} styles\n * @param {?} axis\n * @return {?}\n */\nfunction getBordersSize(styles, axis) {\n    /** @type {?} */\n    const sideA = axis === 'x' ? 'Left' : 'Top';\n    /** @type {?} */\n    const sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n    return (parseFloat(styles[(/** @type {?} */ (`border${sideA}Width`))]) +\n        parseFloat(styles[(/** @type {?} */ (`border${sideB}Width`))]));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} axis\n * @param {?} body\n * @param {?} html\n * @param {?} computedStyle\n * @return {?}\n */\nfunction getSize(axis, body, html, computedStyle) {\n    return Math.max(((/** @type {?} */ (body)))[`offset${axis}`], ((/** @type {?} */ (body)))[`scroll${axis}`], ((/** @type {?} */ (html)))[`client${axis}`], ((/** @type {?} */ (html)))[`offset${axis}`], ((/** @type {?} */ (html)))[`scroll${axis}`], isIE(10)\n        ? (parseInt(((/** @type {?} */ (html)))[`offset${axis}`], 10) +\n            parseInt(computedStyle[(/** @type {?} */ (`margin${axis === 'Height' ? 'Top' : 'Left'}`))], 10) +\n            parseInt(computedStyle[(/** @type {?} */ (`margin${axis === 'Height' ? 'Bottom' : 'Right'}`))], 10))\n        : 0);\n}\n/**\n * @param {?} document\n * @return {?}\n */\nfunction getWindowSizes(document) {\n    /** @type {?} */\n    const body = document.body;\n    /** @type {?} */\n    const html = document.documentElement;\n    /** @type {?} */\n    const computedStyle = isIE(10) && getComputedStyle(html);\n    return {\n        height: getSize('Height', body, html, computedStyle),\n        width: getSize('Width', body, html, computedStyle)\n    };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @param {?} element\n * @param {?=} side\n * @return {?}\n */\nfunction getScroll(element, side = 'top') {\n    /** @type {?} */\n    const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n    /** @type {?} */\n    const nodeName = element.nodeName;\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n        /** @type {?} */\n        const html = element.ownerDocument.documentElement;\n        /** @type {?} */\n        const scrollingElement = element.ownerDocument.scrollingElement || html;\n        return scrollingElement[upperSide];\n    }\n    return element[upperSide];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} offsets\n * @return {?}\n */\nfunction getClientRect(offsets) {\n    return Object.assign(Object.assign({}, offsets), { right: offsets.left + offsets.width, bottom: offsets.top + offsets.height });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction getBoundingClientRect(element) {\n    /** @type {?} */\n    let rect = {};\n    // IE10 10 FIX: Please, don't ask, the element isn't\n    // considered in DOM in some circumstances...\n    // This isn't reproducible in IE10 compatibility mode of IE11\n    try {\n        if (isIE(10)) {\n            rect = element.getBoundingClientRect();\n            /** @type {?} */\n            const scrollTop = getScroll(element, 'top');\n            /** @type {?} */\n            const scrollLeft = getScroll(element, 'left');\n            rect.top += scrollTop;\n            rect.left += scrollLeft;\n            rect.bottom += scrollTop;\n            rect.right += scrollLeft;\n        }\n        else {\n            rect = element.getBoundingClientRect();\n        }\n    }\n    catch (e) {\n        return undefined;\n    }\n    /** @type {?} */\n    const result = {\n        left: rect.left,\n        top: rect.top,\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top\n    };\n    // subtract scrollbar size from sizes\n    /** @type {?} */\n    const sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n    /** @type {?} */\n    const width = sizes.width || element.clientWidth || result.right - result.left;\n    /** @type {?} */\n    const height = sizes.height || element.clientHeight || result.bottom - result.top;\n    /** @type {?} */\n    let horizScrollbar = element.offsetWidth - width;\n    /** @type {?} */\n    let vertScrollbar = element.offsetHeight - height;\n    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n    // we make this check conditional for performance reasons\n    if (horizScrollbar || vertScrollbar) {\n        /** @type {?} */\n        const styles = getStyleComputedProperty(element);\n        horizScrollbar -= getBordersSize(styles, 'x');\n        vertScrollbar -= getBordersSize(styles, 'y');\n        result.width -= horizScrollbar;\n        result.height -= vertScrollbar;\n    }\n    return getClientRect(result);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} rect\n * @param {?} element\n * @param {?=} subtract\n * @return {?}\n */\nfunction includeScroll(rect, element, subtract = false) {\n    /** @type {?} */\n    const scrollTop = getScroll(element, 'top');\n    /** @type {?} */\n    const scrollLeft = getScroll(element, 'left');\n    /** @type {?} */\n    const modifier = subtract ? -1 : 1;\n    rect.top += scrollTop * modifier;\n    rect.bottom += scrollTop * modifier;\n    rect.left += scrollLeft * modifier;\n    rect.right += scrollLeft * modifier;\n    return rect;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} children\n * @param {?} parent\n * @param {?=} fixedPosition\n * @return {?}\n */\nfunction getOffsetRectRelativeToArbitraryNode(children, parent, fixedPosition = false) {\n    /** @type {?} */\n    const isIE10 = isIE(10);\n    /** @type {?} */\n    const isHTML = parent.nodeName === 'HTML';\n    /** @type {?} */\n    const childrenRect = getBoundingClientRect(children);\n    /** @type {?} */\n    const parentRect = getBoundingClientRect(parent);\n    /** @type {?} */\n    const scrollParent = getScrollParent(children);\n    /** @type {?} */\n    const styles = getStyleComputedProperty(parent);\n    /** @type {?} */\n    const borderTopWidth = parseFloat(styles.borderTopWidth);\n    /** @type {?} */\n    const borderLeftWidth = parseFloat(styles.borderLeftWidth);\n    // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n    if (fixedPosition && isHTML) {\n        parentRect.top = Math.max(parentRect.top, 0);\n        parentRect.left = Math.max(parentRect.left, 0);\n    }\n    /** @type {?} */\n    let offsets = getClientRect({\n        top: childrenRect.top - parentRect.top - borderTopWidth,\n        left: childrenRect.left - parentRect.left - borderLeftWidth,\n        width: childrenRect.width,\n        height: childrenRect.height\n    });\n    offsets.marginTop = 0;\n    offsets.marginLeft = 0;\n    // Subtract margins of documentElement in case it's being used as parent\n    // we do this only on HTML because it's the only element that behaves\n    // differently when margins are applied to it. The margins are included in\n    // the box of the documentElement, in the other cases not.\n    if (!isIE10 && isHTML) {\n        /** @type {?} */\n        const marginTop = parseFloat(styles.marginTop);\n        /** @type {?} */\n        const marginLeft = parseFloat(styles.marginLeft);\n        offsets.top -= borderTopWidth - marginTop;\n        offsets.bottom -= borderTopWidth - marginTop;\n        offsets.left -= borderLeftWidth - marginLeft;\n        offsets.right -= borderLeftWidth - marginLeft;\n        // Attach marginTop and marginLeft because in some circumstances we may need them\n        offsets.marginTop = marginTop;\n        offsets.marginLeft = marginLeft;\n    }\n    if (isIE10 && !fixedPosition\n        ? parent.contains(scrollParent)\n        : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n        offsets = includeScroll(offsets, parent);\n    }\n    return offsets;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @param {?=} excludeScroll\n * @return {?}\n */\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element, excludeScroll = false) {\n    /** @type {?} */\n    const html = element.ownerDocument.documentElement;\n    /** @type {?} */\n    const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n    /** @type {?} */\n    const width = Math.max(html.clientWidth, window.innerWidth || 0);\n    /** @type {?} */\n    const height = Math.max(html.clientHeight, window.innerHeight || 0);\n    /** @type {?} */\n    const scrollTop = !excludeScroll ? getScroll(html) : 0;\n    /** @type {?} */\n    const scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n    /** @type {?} */\n    const offset = {\n        top: scrollTop - Number(relativeOffset.top) + Number(relativeOffset.marginTop),\n        left: scrollLeft - Number(relativeOffset.left) + Number(relativeOffset.marginLeft),\n        width,\n        height\n    };\n    return getClientRect(offset);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction isFixed(element) {\n    /** @type {?} */\n    const nodeName = element.nodeName;\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n        return false;\n    }\n    if (getStyleComputedProperty(element, 'position') === 'fixed') {\n        return true;\n    }\n    return isFixed(getParentNode(element));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction getFixedPositionOffsetParent(element) {\n    // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n    if (!element || !element.parentElement || isIE()) {\n        return document.documentElement;\n    }\n    /** @type {?} */\n    let el = element.parentElement;\n    while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n        el = el.parentElement;\n    }\n    return el || document.documentElement;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} target\n * @param {?} host\n * @param {?=} padding\n * @param {?=} boundariesElement\n * @param {?=} fixedPosition\n * @return {?}\n */\nfunction getBoundaries(target, host, padding = 0, boundariesElement, fixedPosition = false) {\n    // NOTE: 1 DOM access here\n    // NOTE: 1 DOM access here\n    /** @type {?} */\n    let boundaries = { top: 0, left: 0 };\n    /** @type {?} */\n    const offsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host);\n    // Handle viewport case\n    if (boundariesElement === 'viewport') {\n        boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n    }\n    else {\n        // Handle other cases based on DOM element used as boundaries\n        /** @type {?} */\n        let boundariesNode;\n        if (boundariesElement === 'scrollParent') {\n            boundariesNode = getScrollParent(getParentNode(host));\n            if (boundariesNode.nodeName === 'BODY') {\n                boundariesNode = target.ownerDocument.documentElement;\n            }\n        }\n        else if (boundariesElement === 'window') {\n            boundariesNode = target.ownerDocument.documentElement;\n        }\n        else {\n            boundariesNode = boundariesElement;\n        }\n        /** @type {?} */\n        const offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n        // In case of HTML, we need a different computation\n        if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n            const { height, width } = getWindowSizes(target.ownerDocument);\n            boundaries.top += offsets.top - offsets.marginTop;\n            boundaries.bottom = Number(height) + Number(offsets.top);\n            boundaries.left += offsets.left - offsets.marginLeft;\n            boundaries.right = Number(width) + Number(offsets.left);\n        }\n        else {\n            // for all the other DOM elements, this one is good\n            boundaries = offsets;\n        }\n    }\n    // Add paddings\n    boundaries.left += padding;\n    boundaries.top += padding;\n    boundaries.right -= padding;\n    boundaries.bottom -= padding;\n    return boundaries;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction getArea({ width, height }) {\n    return width * height;\n}\n/**\n * @param {?} placement\n * @param {?} refRect\n * @param {?} target\n * @param {?} host\n * @param {?=} allowedPositions\n * @param {?=} boundariesElement\n * @param {?=} padding\n * @return {?}\n */\nfunction computeAutoPlacement(placement, refRect, target, host, allowedPositions = ['top', 'bottom', 'right', 'left'], boundariesElement = 'viewport', padding = 0) {\n    if (placement.indexOf('auto') === -1) {\n        return placement;\n    }\n    /** @type {?} */\n    const boundaries = getBoundaries(target, host, padding, boundariesElement);\n    /** @type {?} */\n    const rects = {\n        top: {\n            width: boundaries.width,\n            height: refRect.top - boundaries.top\n        },\n        right: {\n            width: boundaries.right - refRect.right,\n            height: boundaries.height\n        },\n        bottom: {\n            width: boundaries.width,\n            height: boundaries.bottom - refRect.bottom\n        },\n        left: {\n            width: refRect.left - boundaries.left,\n            height: boundaries.height\n        }\n    };\n    /** @type {?} */\n    const sortedAreas = Object.keys(rects)\n        .map((/**\n     * @param {?} key\n     * @return {?}\n     */\n    key => (Object.assign(Object.assign({ key }, rects[key]), { area: getArea(rects[key]) }))))\n        .sort((/**\n     * @param {?} a\n     * @param {?} b\n     * @return {?}\n     */\n    (a, b) => b.area - a.area));\n    /** @type {?} */\n    let filteredAreas = sortedAreas.filter((/**\n     * @param {?} __0\n     * @return {?}\n     */\n    ({ width, height }) => {\n        return width >= target.clientWidth\n            && height >= target.clientHeight;\n    }));\n    filteredAreas = filteredAreas.filter((/**\n     * @param {?} position\n     * @return {?}\n     */\n    (position) => {\n        return allowedPositions\n            .some((/**\n         * @param {?} allowedPosition\n         * @return {?}\n         */\n        (allowedPosition) => {\n            return allowedPosition === position.key;\n        }));\n    }));\n    /** @type {?} */\n    const computedPlacement = filteredAreas.length > 0\n        ? filteredAreas[0].key\n        : sortedAreas[0].key;\n    /** @type {?} */\n    const variation = placement.split(' ')[1];\n    // for tooltip on auto position\n    target.className = target.className.replace(/bs-tooltip-auto/g, `bs-tooltip-${computedPlacement}`);\n    return computedPlacement + (variation ? `-${variation}` : '');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @return {?}\n */\nfunction getOffsets(data) {\n    return {\n        width: data.offsets.target.width,\n        height: data.offsets.target.height,\n        left: Math.floor(data.offsets.target.left),\n        top: Math.round(data.offsets.target.top),\n        bottom: Math.round(data.offsets.target.bottom),\n        right: Math.floor(data.offsets.target.right)\n    };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Get the opposite placement of the given one\n * @param {?} placement\n * @return {?}\n */\nfunction getOppositePlacement(placement) {\n    /** @type {?} */\n    const hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n    return placement.replace(/left|right|bottom|top/g, (/**\n     * @param {?} matched\n     * @return {?}\n     */\n    matched => ((/** @type {?} */ (hash)))[matched]));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Get the opposite placement variation of the given one\n * @param {?} variation\n * @return {?}\n */\nfunction getOppositeVariation(variation) {\n    if (variation === 'right') {\n        return 'left';\n    }\n    else if (variation === 'left') {\n        return 'right';\n    }\n    return variation;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @param {?} element\n * @return {?}\n */\nfunction getOuterSizes(element) {\n    /** @type {?} */\n    const window = element.ownerDocument.defaultView;\n    /** @type {?} */\n    const styles = window.getComputedStyle(element);\n    /** @type {?} */\n    const x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n    /** @type {?} */\n    const y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n    return {\n        width: Number(element.offsetWidth) + y,\n        height: Number(element.offsetHeight) + x\n    };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} target\n * @param {?} host\n * @param {?=} fixedPosition\n * @return {?}\n */\nfunction getReferenceOffsets(target, host, fixedPosition = null) {\n    /** @type {?} */\n    const commonOffsetParent = fixedPosition\n        ? getFixedPositionOffsetParent(target)\n        : findCommonOffsetParent(target, host);\n    return getOffsetRectRelativeToArbitraryNode(host, commonOffsetParent, fixedPosition);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} target\n * @param {?} hostOffsets\n * @param {?} position\n * @return {?}\n */\nfunction getTargetOffsets(target, hostOffsets, position) {\n    /** @type {?} */\n    const placement = position.split(' ')[0];\n    // Get target node sizes\n    /** @type {?} */\n    const targetRect = getOuterSizes(target);\n    // Add position, width and height to our offsets object\n    /** @type {?} */\n    const targetOffsets = {\n        width: targetRect.width,\n        height: targetRect.height\n    };\n    // depending by the target placement we have to compute its offsets slightly differently\n    /** @type {?} */\n    const isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n    /** @type {?} */\n    const mainSide = isHoriz ? 'top' : 'left';\n    /** @type {?} */\n    const secondarySide = isHoriz ? 'left' : 'top';\n    /** @type {?} */\n    const measurement = isHoriz ? 'height' : 'width';\n    /** @type {?} */\n    const secondaryMeasurement = !isHoriz ? 'height' : 'width';\n    ((/** @type {?} */ (targetOffsets)))[mainSide] =\n        hostOffsets[mainSide] +\n            hostOffsets[measurement] / 2 -\n            targetRect[measurement] / 2;\n    ((/** @type {?} */ (targetOffsets)))[secondarySide] = placement === secondarySide\n        ? hostOffsets[secondarySide] - targetRect[secondaryMeasurement]\n        : ((/** @type {?} */ (hostOffsets)))[getOppositePlacement(secondarySide)];\n    return targetOffsets;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Helper used to know if the given modifier is enabled.\n * @param {?} options\n * @param {?} modifierName\n * @return {?}\n */\nfunction isModifierEnabled(options, modifierName) {\n    return options\n        && options.modifiers\n        && options.modifiers[modifierName]\n        && options.modifiers[modifierName].enabled;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Tells if a given input is a number\n * @param {?} n\n * @return {?}\n */\nfunction isNumeric(n) {\n    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @param {?=} renderer\n * @return {?}\n */\nfunction updateContainerClass(data, renderer) {\n    /** @type {?} */\n    const target = data.instance.target;\n    /** @type {?} */\n    let containerClass = target.className;\n    if (data.placementAuto) {\n        containerClass = containerClass.replace(/bs-popover-auto/g, `bs-popover-${data.placement}`);\n        containerClass = containerClass.replace(/bs-tooltip-auto/g, `bs-tooltip-${data.placement}`);\n        containerClass = containerClass.replace(/\\sauto/g, ` ${data.placement}`);\n        if (containerClass.indexOf('popover') !== -1 && containerClass.indexOf('popover-auto') === -1) {\n            containerClass += ' popover-auto';\n        }\n        if (containerClass.indexOf('tooltip') !== -1 && containerClass.indexOf('tooltip-auto') === -1) {\n            containerClass += ' tooltip-auto';\n        }\n    }\n    containerClass = containerClass.replace(/left|right|top|bottom/g, `${data.placement.split(' ')[0]}`);\n    if (renderer) {\n        renderer.setAttribute(target, 'class', containerClass);\n        return;\n    }\n    target.className = containerClass;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @param {?} styles\n * @param {?=} renderer\n * @return {?}\n */\nfunction setStyles(element, styles, renderer) {\n    Object.keys(styles).forEach((/**\n     * @param {?} prop\n     * @return {?}\n     */\n    (prop) => {\n        /** @type {?} */\n        let unit = '';\n        // add unit if the value is numeric and is one of the following\n        if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 &&\n            isNumeric(styles[prop])) {\n            unit = 'px';\n        }\n        if (renderer) {\n            renderer.setStyle(element, prop, `${String(styles[prop])}${unit}`);\n            return;\n        }\n        element.style[prop] = String(styles[prop]) + unit;\n    }));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @return {?}\n */\nfunction arrow(data) {\n    /** @type {?} */\n    let targetOffsets = data.offsets.target;\n    // if arrowElement is a string, suppose it's a CSS selector\n    /** @type {?} */\n    const arrowElement = data.instance.target.querySelector('.arrow');\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n        return data;\n    }\n    /** @type {?} */\n    const isVertical = ['left', 'right'].indexOf(data.placement.split(' ')[0]) !== -1;\n    /** @type {?} */\n    const len = isVertical ? 'height' : 'width';\n    /** @type {?} */\n    const sideCapitalized = isVertical ? 'Top' : 'Left';\n    /** @type {?} */\n    const side = sideCapitalized.toLowerCase();\n    /** @type {?} */\n    const altSide = isVertical ? 'left' : 'top';\n    /** @type {?} */\n    const opSide = isVertical ? 'bottom' : 'right';\n    /** @type {?} */\n    const arrowElementSize = getOuterSizes(arrowElement)[len];\n    /** @type {?} */\n    const placementVariation = data.placement.split(' ')[1];\n    // top/left side\n    if (data.offsets.host[opSide] - arrowElementSize < ((/** @type {?} */ (targetOffsets)))[side]) {\n        ((/** @type {?} */ (targetOffsets)))[side] -=\n            ((/** @type {?} */ (targetOffsets)))[side] - (data.offsets.host[opSide] - arrowElementSize);\n    }\n    // bottom/right side\n    if (Number(((/** @type {?} */ (data))).offsets.host[side]) + Number(arrowElementSize) > ((/** @type {?} */ (targetOffsets)))[opSide]) {\n        ((/** @type {?} */ (targetOffsets)))[side] +=\n            Number(((/** @type {?} */ (data))).offsets.host[side]) + Number(arrowElementSize) - Number(((/** @type {?} */ (targetOffsets)))[opSide]);\n    }\n    targetOffsets = getClientRect(targetOffsets);\n    // Compute the sideValue using the updated target offsets\n    // take target margin in account because we don't have this info available\n    /** @type {?} */\n    const css = getStyleComputedProperty(data.instance.target);\n    /** @type {?} */\n    const targetMarginSide = parseFloat(css[`margin${sideCapitalized}`]);\n    /** @type {?} */\n    const targetBorderSide = parseFloat(css[`border${sideCapitalized}Width`]);\n    // compute center of the target\n    /** @type {?} */\n    let center;\n    if (!placementVariation) {\n        center = Number(((/** @type {?} */ (data))).offsets.host[side]) + Number(data.offsets.host[len] / 2 - arrowElementSize / 2);\n    }\n    else {\n        /** @type {?} */\n        const targetBorderRadius = parseFloat(css.borderRadius);\n        /** @type {?} */\n        const targetSideArrowOffset = Number(targetMarginSide + targetBorderSide + targetBorderRadius);\n        center = side === placementVariation ?\n            Number(((/** @type {?} */ (data))).offsets.host[side]) + targetSideArrowOffset :\n            Number(((/** @type {?} */ (data))).offsets.host[side]) + Number(data.offsets.host[len] - targetSideArrowOffset);\n    }\n    /** @type {?} */\n    let sideValue = center - ((/** @type {?} */ (targetOffsets)))[side] - targetMarginSide - targetBorderSide;\n    // prevent arrowElement from being placed not contiguously to its target\n    sideValue = Math.max(Math.min(targetOffsets[len] - arrowElementSize, sideValue), 0);\n    data.offsets.arrow = {\n        [side]: Math.round(sideValue),\n        [altSide]: '' // make sure to unset any eventual altSide value from the DOM node\n    };\n    data.instance.arrow = arrowElement;\n    return data;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @return {?}\n */\nfunction flip(data) {\n    data.offsets.target = getClientRect(data.offsets.target);\n    if (!isModifierEnabled(data.options, 'flip')) {\n        data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), getTargetOffsets(data.instance.target, data.offsets.host, data.placement));\n        return data;\n    }\n    /** @type {?} */\n    const boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n    'viewport', false // positionFixed\n    );\n    /** @type {?} */\n    let placement = data.placement.split(' ')[0];\n    /** @type {?} */\n    let variation = data.placement.split(' ')[1] || '';\n    /** @type {?} */\n    const offsetsHost = data.offsets.host;\n    /** @type {?} */\n    const target = data.instance.target;\n    /** @type {?} */\n    const host = data.instance.host;\n    /** @type {?} */\n    const adaptivePosition = computeAutoPlacement('auto', offsetsHost, target, host, data.options.allowedPositions);\n    /** @type {?} */\n    const flipOrder = [placement, adaptivePosition];\n    /* tslint:disable-next-line: cyclomatic-complexity */\n    flipOrder.forEach((/**\n     * @param {?} step\n     * @param {?} index\n     * @return {?}\n     */\n    (step, index) => {\n        if (placement !== step || flipOrder.length === index + 1) {\n            return data;\n        }\n        placement = data.placement.split(' ')[0];\n        // using floor because the host offsets may contain decimals we are not going to consider here\n        /** @type {?} */\n        const overlapsRef = (placement === 'left' &&\n            Math.floor(data.offsets.target.right) > Math.floor(data.offsets.host.left)) ||\n            (placement === 'right' &&\n                Math.floor(data.offsets.target.left) < Math.floor(data.offsets.host.right)) ||\n            (placement === 'top' &&\n                Math.floor(data.offsets.target.bottom) > Math.floor(data.offsets.host.top)) ||\n            (placement === 'bottom' &&\n                Math.floor(data.offsets.target.top) < Math.floor(data.offsets.host.bottom));\n        /** @type {?} */\n        const overflowsLeft = Math.floor(data.offsets.target.left) < Math.floor(boundaries.left);\n        /** @type {?} */\n        const overflowsRight = Math.floor(data.offsets.target.right) > Math.floor(boundaries.right);\n        /** @type {?} */\n        const overflowsTop = Math.floor(data.offsets.target.top) < Math.floor(boundaries.top);\n        /** @type {?} */\n        const overflowsBottom = Math.floor(data.offsets.target.bottom) > Math.floor(boundaries.bottom);\n        /** @type {?} */\n        const overflowsBoundaries = (placement === 'left' && overflowsLeft) ||\n            (placement === 'right' && overflowsRight) ||\n            (placement === 'top' && overflowsTop) ||\n            (placement === 'bottom' && overflowsBottom);\n        // flip the variation if required\n        /** @type {?} */\n        const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n        /** @type {?} */\n        const flippedVariation = ((isVertical && variation === 'left' && overflowsLeft) ||\n            (isVertical && variation === 'right' && overflowsRight) ||\n            (!isVertical && variation === 'left' && overflowsTop) ||\n            (!isVertical && variation === 'right' && overflowsBottom));\n        if (overlapsRef || overflowsBoundaries || flippedVariation) {\n            if (overlapsRef || overflowsBoundaries) {\n                placement = flipOrder[index + 1];\n            }\n            if (flippedVariation) {\n                variation = getOppositeVariation(variation);\n            }\n            data.placement = placement + (variation ? ` ${variation}` : '');\n            data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), getTargetOffsets(data.instance.target, data.offsets.host, data.placement));\n        }\n    }));\n    return data;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} targetElement\n * @param {?} hostElement\n * @param {?} position\n * @param {?} options\n * @return {?}\n */\nfunction initData(targetElement, hostElement, position, options) {\n    /** @type {?} */\n    const hostElPosition = getReferenceOffsets(targetElement, hostElement);\n    if (!position.match(/^(auto)*\\s*(left|right|top|bottom)*$/)\n        && !position.match(/^(left|right|top|bottom)*(?: (left|right|top|bottom))?\\s*(start|end)*$/)) {\n        /* tslint:disable-next-line: no-parameter-reassignment */\n        position = 'auto';\n    }\n    /** @type {?} */\n    const placementAuto = !!position.match(/auto/g);\n    // support old placements 'auto left|right|top|bottom'\n    /** @type {?} */\n    let placement = position.match(/auto\\s(left|right|top|bottom)/)\n        ? position.split(' ')[1] || 'auto'\n        : position;\n    // Normalize placements that have identical main placement and variation (\"right right\" => \"right\").\n    /** @type {?} */\n    const matches = placement.match(/^(left|right|top|bottom)* ?(?!\\1)(left|right|top|bottom)?/);\n    if (matches) {\n        placement = matches[1] + (matches[2] ? ` ${matches[2]}` : '');\n    }\n    // \"left right\", \"top bottom\" etc. placements also considered incorrect.\n    if (['left right', 'right left', 'top bottom', 'bottom top'].indexOf(placement) !== -1) {\n        placement = 'auto';\n    }\n    /** @type {?} */\n    const targetOffset = getTargetOffsets(targetElement, hostElPosition, placement);\n    placement = computeAutoPlacement(placement, hostElPosition, targetElement, hostElement, options ? options.allowedPositions : undefined);\n    return {\n        options,\n        instance: {\n            target: targetElement,\n            host: hostElement,\n            arrow: null\n        },\n        offsets: {\n            target: targetOffset,\n            host: hostElPosition,\n            arrow: null\n        },\n        positionFixed: false,\n        placement,\n        placementAuto\n    };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @return {?}\n */\nfunction preventOverflow(data) {\n    if (!isModifierEnabled(data.options, 'preventOverflow')) {\n        return data;\n    }\n    // NOTE: DOM access here\n    // resets the targetOffsets's position so that the document size can be calculated excluding\n    // the size of the targetOffsets element itself\n    /** @type {?} */\n    const transformProp = 'transform';\n    /** @type {?} */\n    const targetStyles = data.instance.target.style;\n    // assignment to help minification\n    const { top, left, [transformProp]: transform } = targetStyles;\n    targetStyles.top = '';\n    targetStyles.left = '';\n    targetStyles[transformProp] = '';\n    /** @type {?} */\n    const boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n    'scrollParent', false // positionFixed\n    );\n    // NOTE: DOM access here\n    // restores the original style properties after the offsets have been computed\n    targetStyles.top = top;\n    targetStyles.left = left;\n    targetStyles[transformProp] = transform;\n    /** @type {?} */\n    const order = ['left', 'right', 'top', 'bottom'];\n    /** @type {?} */\n    const check = {\n        /**\n         * @param {?} placement\n         * @return {?}\n         */\n        primary(placement) {\n            /** @type {?} */\n            let value = ((/** @type {?} */ (data))).offsets.target[placement];\n            if (((/** @type {?} */ (data))).offsets.target[placement] < boundaries[placement] &&\n                !false // options.escapeWithReference\n            ) {\n                value = Math.max(((/** @type {?} */ (data))).offsets.target[placement], boundaries[placement]);\n            }\n            return { [placement]: value };\n        },\n        /**\n         * @param {?} placement\n         * @return {?}\n         */\n        secondary(placement) {\n            /** @type {?} */\n            const mainSide = placement === 'right' ? 'left' : 'top';\n            /** @type {?} */\n            let value = data.offsets.target[mainSide];\n            if (((/** @type {?} */ (data))).offsets.target[placement] > boundaries[placement] &&\n                !false // escapeWithReference\n            ) {\n                value = Math.min(data.offsets.target[mainSide], boundaries[placement] -\n                    (placement === 'right' ? data.offsets.target.width : data.offsets.target.height));\n            }\n            return { [mainSide]: value };\n        }\n    };\n    /** @type {?} */\n    let side;\n    order.forEach((/**\n     * @param {?} placement\n     * @return {?}\n     */\n    placement => {\n        side = ['left', 'top']\n            .indexOf(placement) !== -1\n            ? 'primary'\n            : 'secondary';\n        data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), ((/** @type {?} */ (check)))[side](placement));\n    }));\n    return data;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @return {?}\n */\nfunction shift(data) {\n    /** @type {?} */\n    const placement = data.placement;\n    /** @type {?} */\n    const basePlacement = placement.split(' ')[0];\n    /** @type {?} */\n    const shiftVariation = placement.split(' ')[1];\n    if (shiftVariation) {\n        const { host, target } = data.offsets;\n        /** @type {?} */\n        const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n        /** @type {?} */\n        const side = isVertical ? 'left' : 'top';\n        /** @type {?} */\n        const measurement = isVertical ? 'width' : 'height';\n        /** @type {?} */\n        const shiftOffsets = {\n            start: { [side]: host[side] },\n            end: {\n                [side]: host[side] + host[measurement] - target[measurement]\n            }\n        };\n        data.offsets.target = Object.assign(Object.assign({}, target), {\n            [side]: (side === shiftVariation ? ((/** @type {?} */ (shiftOffsets))).start[side] : ((/** @type {?} */ (shiftOffsets))).end[side])\n        });\n    }\n    return data;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass Positioning {\n    /**\n     * @param {?} hostElement\n     * @param {?} targetElement\n     * @param {?=} round\n     * @return {?}\n     */\n    position(hostElement, targetElement, round = true) {\n        return this.offset(hostElement, targetElement, false);\n    }\n    /**\n     * @param {?} hostElement\n     * @param {?} targetElement\n     * @param {?=} round\n     * @return {?}\n     */\n    offset(hostElement, targetElement, round = true) {\n        return getReferenceOffsets(targetElement, hostElement);\n    }\n    /**\n     * @param {?} hostElement\n     * @param {?} targetElement\n     * @param {?} position\n     * @param {?=} appendToBody\n     * @param {?=} options\n     * @return {?}\n     */\n    positionElements(hostElement, targetElement, position, appendToBody, options) {\n        /** @type {?} */\n        const chainOfModifiers = [flip, shift, preventOverflow, arrow];\n        return chainOfModifiers.reduce((/**\n         * @param {?} modifiedData\n         * @param {?} modifier\n         * @return {?}\n         */\n        (modifiedData, modifier) => modifier(modifiedData)), initData(targetElement, hostElement, position, options));\n    }\n}\n/** @type {?} */\nconst positionService = new Positioning();\n/**\n * @param {?} hostElement\n * @param {?} targetElement\n * @param {?} placement\n * @param {?=} appendToBody\n * @param {?=} options\n * @param {?=} renderer\n * @return {?}\n */\nfunction positionElements(hostElement, targetElement, placement, appendToBody, options, renderer) {\n    /** @type {?} */\n    const data = positionService.positionElements(hostElement, targetElement, placement, appendToBody, options);\n    /** @type {?} */\n    const offsets = getOffsets(data);\n    setStyles(targetElement, {\n        'will-change': 'transform',\n        top: '0px',\n        left: '0px',\n        transform: `translate3d(${offsets.left}px, ${offsets.top}px, 0px)`\n    }, renderer);\n    if (data.instance.arrow) {\n        setStyles(data.instance.arrow, data.offsets.arrow, renderer);\n    }\n    updateContainerClass(data, renderer);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @record\n */\nfunction PositioningOptions() { }\nif (false) {\n    /**\n     * The DOM element, ElementRef, or a selector string of an element which will be moved\n     * @type {?|undefined}\n     */\n    PositioningOptions.prototype.element;\n    /**\n     * The DOM element, ElementRef, or a selector string of an element which the element will be attached to\n     * @type {?|undefined}\n     */\n    PositioningOptions.prototype.target;\n    /**\n     * A string of the form 'vert-attachment horiz-attachment' or 'placement'\n     * - placement can be \"top\", \"bottom\", \"left\", \"right\"\n     * not yet supported:\n     * - vert-attachment can be any of 'top', 'middle', 'bottom'\n     * - horiz-attachment can be any of 'left', 'center', 'right'\n     * @type {?|undefined}\n     */\n    PositioningOptions.prototype.attachment;\n    /**\n     * A string similar to `attachment`. The one difference is that, if it's not provided,\n     * `targetAttachment` will assume the mirror image of `attachment`.\n     * @type {?|undefined}\n     */\n    PositioningOptions.prototype.targetAttachment;\n    /**\n     * A string of the form 'vert-offset horiz-offset'\n     * - vert-offset and horiz-offset can be of the form \"20px\" or \"55%\"\n     * @type {?|undefined}\n     */\n    PositioningOptions.prototype.offset;\n    /**\n     * A string similar to `offset`, but referring to the offset of the target\n     * @type {?|undefined}\n     */\n    PositioningOptions.prototype.targetOffset;\n    /**\n     * If true component will be attached to body\n     * @type {?|undefined}\n     */\n    PositioningOptions.prototype.appendToBody;\n}\nclass PositioningService {\n    /**\n     * @param {?} ngZone\n     * @param {?} rendererFactory\n     * @param {?} platformId\n     */\n    constructor(ngZone, rendererFactory, platformId) {\n        this.update$$ = new Subject();\n        this.positionElements = new Map();\n        this.isDisabled = false;\n        if (isPlatformBrowser(platformId)) {\n            ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                this.triggerEvent$ = merge(fromEvent(window, 'scroll', { passive: true }), fromEvent(window, 'resize', { passive: true }), \n                /* tslint:disable-next-line: deprecation */\n                of(0, animationFrameScheduler), this.update$$);\n                this.triggerEvent$.subscribe((/**\n                 * @return {?}\n                 */\n                () => {\n                    if (this.isDisabled) {\n                        return;\n                    }\n                    this.positionElements\n                        /* tslint:disable-next-line: no-any */\n                        .forEach((/**\n                     * @param {?} positionElement\n                     * @return {?}\n                     */\n                    (positionElement) => {\n                        positionElements(_getHtmlElement(positionElement.target), _getHtmlElement(positionElement.element), positionElement.attachment, positionElement.appendToBody, this.options, rendererFactory.createRenderer(null, null));\n                    }));\n                }));\n            }));\n        }\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    position(options) {\n        this.addPositionElement(options);\n    }\n    /**\n     * @return {?}\n     */\n    get event$() {\n        return this.triggerEvent$;\n    }\n    /**\n     * @return {?}\n     */\n    disable() {\n        this.isDisabled = true;\n    }\n    /**\n     * @return {?}\n     */\n    enable() {\n        this.isDisabled = false;\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    addPositionElement(options) {\n        this.positionElements.set(_getHtmlElement(options.element), options);\n    }\n    /**\n     * @return {?}\n     */\n    calcPosition() {\n        this.update$$.next();\n    }\n    /**\n     * @param {?} elRef\n     * @return {?}\n     */\n    deletePositionElement(elRef) {\n        this.positionElements.delete(_getHtmlElement(elRef));\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    setOptions(options) {\n        this.options = options;\n    }\n}\nPositioningService.Éµfac = function PositioningService_Factory(t) { return new (t || PositioningService)(Éµngcc0.ÉµÉµinject(Éµngcc0.NgZone), Éµngcc0.ÉµÉµinject(Éµngcc0.RendererFactory2), Éµngcc0.ÉµÉµinject(PLATFORM_ID)); };\nPositioningService.Éµprov = Éµngcc0.ÉµÉµdefineInjectable({ token: PositioningService, factory: PositioningService.Éµfac });\n/** @nocollapse */\nPositioningService.ctorParameters = () => [\n    { type: NgZone },\n    { type: RendererFactory2 },\n    { type: Number, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(PositioningService, [{\n        type: Injectable\n    }], function () { return [{ type: Éµngcc0.NgZone }, { type: Éµngcc0.RendererFactory2 }, { type: Number, decorators: [{\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }]; }, null); })();\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    PositioningService.prototype.options;\n    /**\n     * @type {?}\n     * @private\n     */\n    PositioningService.prototype.update$$;\n    /**\n     * @type {?}\n     * @private\n     */\n    PositioningService.prototype.positionElements;\n    /**\n     * @type {?}\n     * @private\n     */\n    PositioningService.prototype.triggerEvent$;\n    /**\n     * @type {?}\n     * @private\n     */\n    PositioningService.prototype.isDisabled;\n}\n/**\n * @param {?} element\n * @return {?}\n */\nfunction _getHtmlElement(element) {\n    // it means that we got a selector\n    if (typeof element === 'string') {\n        return document.querySelector(element);\n    }\n    if (element instanceof ElementRef) {\n        return element.nativeElement;\n    }\n    return element;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { Positioning, PositioningService, positionElements };\n\n//# sourceMappingURL=ngx-bootstrap-positioning.js.map"]},"metadata":{},"sourceType":"module"}