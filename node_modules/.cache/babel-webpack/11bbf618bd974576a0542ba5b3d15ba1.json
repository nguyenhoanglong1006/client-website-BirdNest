{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = require('../Observable');\n\nvar ScalarObservable_1 = require('./ScalarObservable');\n\nvar EmptyObservable_1 = require('./EmptyObservable');\n\nvar isScheduler_1 = require('../util/isScheduler');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar ArrayObservable = function (_super) {\n  __extends(ArrayObservable, _super);\n\n  function ArrayObservable(array, scheduler) {\n    _super.call(this);\n\n    this.array = array;\n    this.scheduler = scheduler;\n\n    if (!scheduler && array.length === 1) {\n      this._isScalar = true;\n      this.value = array[0];\n    }\n  }\n\n  ArrayObservable.create = function (array, scheduler) {\n    return new ArrayObservable(array, scheduler);\n  };\n  /**\n   * Creates an Observable that emits some values you specify as arguments,\n   * immediately one after the other, and then emits a complete notification.\n   *\n   * <span class=\"informal\">Emits the arguments you provide, then completes.\n   * </span>\n   *\n   * <img src=\"./img/of.png\" width=\"100%\">\n   *\n   * This static operator is useful for creating a simple Observable that only\n   * emits the arguments given, and the complete notification thereafter. It can\n   * be used for composing with other Observables, such as with {@link concat}.\n   * By default, it uses a `null` IScheduler, which means the `next`\n   * notifications are sent synchronously, although with a different IScheduler\n   * it is possible to determine when those notifications will be delivered.\n   *\n   * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n   * var numbers = Rx.Observable.of(10, 20, 30);\n   * var letters = Rx.Observable.of('a', 'b', 'c');\n   * var interval = Rx.Observable.interval(1000);\n   * var result = numbers.concat(letters).concat(interval);\n   * result.subscribe(x => console.log(x));\n   *\n   * @see {@link create}\n   * @see {@link empty}\n   * @see {@link never}\n   * @see {@link throw}\n   *\n   * @param {...T} values Arguments that represent `next` values to be emitted.\n   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n   * the emissions of the `next` notifications.\n   * @return {Observable<T>} An Observable that emits each given input value.\n   * @static true\n   * @name of\n   * @owner Observable\n   */\n\n\n  ArrayObservable.of = function () {\n    var array = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      array[_i - 0] = arguments[_i];\n    }\n\n    var scheduler = array[array.length - 1];\n\n    if (isScheduler_1.isScheduler(scheduler)) {\n      array.pop();\n    } else {\n      scheduler = null;\n    }\n\n    var len = array.length;\n\n    if (len > 1) {\n      return new ArrayObservable(array, scheduler);\n    } else if (len === 1) {\n      return new ScalarObservable_1.ScalarObservable(array[0], scheduler);\n    } else {\n      return new EmptyObservable_1.EmptyObservable(scheduler);\n    }\n  };\n\n  ArrayObservable.dispatch = function (state) {\n    var array = state.array,\n        index = state.index,\n        count = state.count,\n        subscriber = state.subscriber;\n\n    if (index >= count) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(array[index]);\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.index = index + 1;\n    this.schedule(state);\n  };\n  /** @deprecated internal use only */\n\n\n  ArrayObservable.prototype._subscribe = function (subscriber) {\n    var index = 0;\n    var array = this.array;\n    var count = array.length;\n    var scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(ArrayObservable.dispatch, 0, {\n        array: array,\n        index: index,\n        count: count,\n        subscriber: subscriber\n      });\n    } else {\n      for (var i = 0; i < count && !subscriber.closed; i++) {\n        subscriber.next(array[i]);\n      }\n\n      subscriber.complete();\n    }\n  };\n\n  return ArrayObservable;\n}(Observable_1.Observable);\n\nexports.ArrayObservable = ArrayObservable; //# sourceMappingURL=ArrayObservable.js.map","map":{"version":3,"sources":["/Users/nguyenlong/ProjectCompany/2nMart/websiteclient-2nmart.vn/node_modules/ng5-slider/node_modules/rxjs/observable/ArrayObservable.js"],"names":["__extends","d","b","p","hasOwnProperty","__","constructor","prototype","Object","create","Observable_1","require","ScalarObservable_1","EmptyObservable_1","isScheduler_1","ArrayObservable","_super","array","scheduler","call","length","_isScalar","value","of","_i","arguments","isScheduler","pop","len","ScalarObservable","EmptyObservable","dispatch","state","index","count","subscriber","complete","next","closed","schedule","_subscribe","i","Observable","exports"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar ScalarObservable_1 = require('./ScalarObservable');\nvar EmptyObservable_1 = require('./EmptyObservable');\nvar isScheduler_1 = require('../util/isScheduler');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ArrayObservable = (function (_super) {\n    __extends(ArrayObservable, _super);\n    function ArrayObservable(array, scheduler) {\n        _super.call(this);\n        this.array = array;\n        this.scheduler = scheduler;\n        if (!scheduler && array.length === 1) {\n            this._isScalar = true;\n            this.value = array[0];\n        }\n    }\n    ArrayObservable.create = function (array, scheduler) {\n        return new ArrayObservable(array, scheduler);\n    };\n    /**\n     * Creates an Observable that emits some values you specify as arguments,\n     * immediately one after the other, and then emits a complete notification.\n     *\n     * <span class=\"informal\">Emits the arguments you provide, then completes.\n     * </span>\n     *\n     * <img src=\"./img/of.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that only\n     * emits the arguments given, and the complete notification thereafter. It can\n     * be used for composing with other Observables, such as with {@link concat}.\n     * By default, it uses a `null` IScheduler, which means the `next`\n     * notifications are sent synchronously, although with a different IScheduler\n     * it is possible to determine when those notifications will be delivered.\n     *\n     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n     * var numbers = Rx.Observable.of(10, 20, 30);\n     * var letters = Rx.Observable.of('a', 'b', 'c');\n     * var interval = Rx.Observable.interval(1000);\n     * var result = numbers.concat(letters).concat(interval);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link create}\n     * @see {@link empty}\n     * @see {@link never}\n     * @see {@link throw}\n     *\n     * @param {...T} values Arguments that represent `next` values to be emitted.\n     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n     * the emissions of the `next` notifications.\n     * @return {Observable<T>} An Observable that emits each given input value.\n     * @static true\n     * @name of\n     * @owner Observable\n     */\n    ArrayObservable.of = function () {\n        var array = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            array[_i - 0] = arguments[_i];\n        }\n        var scheduler = array[array.length - 1];\n        if (isScheduler_1.isScheduler(scheduler)) {\n            array.pop();\n        }\n        else {\n            scheduler = null;\n        }\n        var len = array.length;\n        if (len > 1) {\n            return new ArrayObservable(array, scheduler);\n        }\n        else if (len === 1) {\n            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);\n        }\n        else {\n            return new EmptyObservable_1.EmptyObservable(scheduler);\n        }\n    };\n    ArrayObservable.dispatch = function (state) {\n        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;\n        if (index >= count) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(array[index]);\n        if (subscriber.closed) {\n            return;\n        }\n        state.index = index + 1;\n        this.schedule(state);\n    };\n    /** @deprecated internal use only */ ArrayObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var array = this.array;\n        var count = array.length;\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(ArrayObservable.dispatch, 0, {\n                array: array, index: index, count: count, subscriber: subscriber\n            });\n        }\n        else {\n            for (var i = 0; i < count && !subscriber.closed; i++) {\n                subscriber.next(array[i]);\n            }\n            subscriber.complete();\n        }\n    };\n    return ArrayObservable;\n}(Observable_1.Observable));\nexports.ArrayObservable = ArrayObservable;\n//# sourceMappingURL=ArrayObservable.js.map"]},"metadata":{},"sourceType":"script"}