{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar root_1 = require('../util/root');\n\nvar Observable_1 = require('../Observable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar PromiseObservable = function (_super) {\n  __extends(PromiseObservable, _super);\n\n  function PromiseObservable(promise, scheduler) {\n    _super.call(this);\n\n    this.promise = promise;\n    this.scheduler = scheduler;\n  }\n  /**\n   * Converts a Promise to an Observable.\n   *\n   * <span class=\"informal\">Returns an Observable that just emits the Promise's\n   * resolved value, then completes.</span>\n   *\n   * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n   * Observable. If the Promise resolves with a value, the output Observable\n   * emits that resolved value as a `next`, and then completes. If the Promise\n   * is rejected, then the output Observable emits the corresponding Error.\n   *\n   * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n   * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n   * result.subscribe(x => console.log(x), e => console.error(e));\n   *\n   * @see {@link bindCallback}\n   * @see {@link from}\n   *\n   * @param {PromiseLike<T>} promise The promise to be converted.\n   * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling\n   * the delivery of the resolved value (or the rejection).\n   * @return {Observable<T>} An Observable which wraps the Promise.\n   * @static true\n   * @name fromPromise\n   * @owner Observable\n   */\n\n\n  PromiseObservable.create = function (promise, scheduler) {\n    return new PromiseObservable(promise, scheduler);\n  };\n  /** @deprecated internal use only */\n\n\n  PromiseObservable.prototype._subscribe = function (subscriber) {\n    var _this = this;\n\n    var promise = this.promise;\n    var scheduler = this.scheduler;\n\n    if (scheduler == null) {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          subscriber.next(this.value);\n          subscriber.complete();\n        }\n      } else {\n        promise.then(function (value) {\n          _this.value = value;\n          _this._isScalar = true;\n\n          if (!subscriber.closed) {\n            subscriber.next(value);\n            subscriber.complete();\n          }\n        }, function (err) {\n          if (!subscriber.closed) {\n            subscriber.error(err);\n          }\n        }).then(null, function (err) {\n          // escape the promise trap, throw unhandled errors\n          root_1.root.setTimeout(function () {\n            throw err;\n          });\n        });\n      }\n    } else {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          return scheduler.schedule(dispatchNext, 0, {\n            value: this.value,\n            subscriber: subscriber\n          });\n        }\n      } else {\n        promise.then(function (value) {\n          _this.value = value;\n          _this._isScalar = true;\n\n          if (!subscriber.closed) {\n            subscriber.add(scheduler.schedule(dispatchNext, 0, {\n              value: value,\n              subscriber: subscriber\n            }));\n          }\n        }, function (err) {\n          if (!subscriber.closed) {\n            subscriber.add(scheduler.schedule(dispatchError, 0, {\n              err: err,\n              subscriber: subscriber\n            }));\n          }\n        }).then(null, function (err) {\n          // escape the promise trap, throw unhandled errors\n          root_1.root.setTimeout(function () {\n            throw err;\n          });\n        });\n      }\n    }\n  };\n\n  return PromiseObservable;\n}(Observable_1.Observable);\n\nexports.PromiseObservable = PromiseObservable;\n\nfunction dispatchNext(arg) {\n  var value = arg.value,\n      subscriber = arg.subscriber;\n\n  if (!subscriber.closed) {\n    subscriber.next(value);\n    subscriber.complete();\n  }\n}\n\nfunction dispatchError(arg) {\n  var err = arg.err,\n      subscriber = arg.subscriber;\n\n  if (!subscriber.closed) {\n    subscriber.error(err);\n  }\n} //# sourceMappingURL=PromiseObservable.js.map","map":{"version":3,"sources":["/Users/nguyenlong/ProjectCompany/2nMart/websiteclient-2nmart.vn/node_modules/ng5-slider/node_modules/rxjs/observable/PromiseObservable.js"],"names":["__extends","d","b","p","hasOwnProperty","__","constructor","prototype","Object","create","root_1","require","Observable_1","PromiseObservable","_super","promise","scheduler","call","_subscribe","subscriber","_this","_isScalar","closed","next","value","complete","then","err","error","root","setTimeout","schedule","dispatchNext","add","dispatchError","Observable","exports","arg"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = require('../util/root');\nvar Observable_1 = require('../Observable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar PromiseObservable = (function (_super) {\n    __extends(PromiseObservable, _super);\n    function PromiseObservable(promise, scheduler) {\n        _super.call(this);\n        this.promise = promise;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Converts a Promise to an Observable.\n     *\n     * <span class=\"informal\">Returns an Observable that just emits the Promise's\n     * resolved value, then completes.</span>\n     *\n     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n     * Observable. If the Promise resolves with a value, the output Observable\n     * emits that resolved value as a `next`, and then completes. If the Promise\n     * is rejected, then the output Observable emits the corresponding Error.\n     *\n     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * @see {@link bindCallback}\n     * @see {@link from}\n     *\n     * @param {PromiseLike<T>} promise The promise to be converted.\n     * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling\n     * the delivery of the resolved value (or the rejection).\n     * @return {Observable<T>} An Observable which wraps the Promise.\n     * @static true\n     * @name fromPromise\n     * @owner Observable\n     */\n    PromiseObservable.create = function (promise, scheduler) {\n        return new PromiseObservable(promise, scheduler);\n    };\n    /** @deprecated internal use only */ PromiseObservable.prototype._subscribe = function (subscriber) {\n        var _this = this;\n        var promise = this.promise;\n        var scheduler = this.scheduler;\n        if (scheduler == null) {\n            if (this._isScalar) {\n                if (!subscriber.closed) {\n                    subscriber.next(this.value);\n                    subscriber.complete();\n                }\n            }\n            else {\n                promise.then(function (value) {\n                    _this.value = value;\n                    _this._isScalar = true;\n                    if (!subscriber.closed) {\n                        subscriber.next(value);\n                        subscriber.complete();\n                    }\n                }, function (err) {\n                    if (!subscriber.closed) {\n                        subscriber.error(err);\n                    }\n                })\n                    .then(null, function (err) {\n                    // escape the promise trap, throw unhandled errors\n                    root_1.root.setTimeout(function () { throw err; });\n                });\n            }\n        }\n        else {\n            if (this._isScalar) {\n                if (!subscriber.closed) {\n                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });\n                }\n            }\n            else {\n                promise.then(function (value) {\n                    _this.value = value;\n                    _this._isScalar = true;\n                    if (!subscriber.closed) {\n                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));\n                    }\n                }, function (err) {\n                    if (!subscriber.closed) {\n                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));\n                    }\n                })\n                    .then(null, function (err) {\n                    // escape the promise trap, throw unhandled errors\n                    root_1.root.setTimeout(function () { throw err; });\n                });\n            }\n        }\n    };\n    return PromiseObservable;\n}(Observable_1.Observable));\nexports.PromiseObservable = PromiseObservable;\nfunction dispatchNext(arg) {\n    var value = arg.value, subscriber = arg.subscriber;\n    if (!subscriber.closed) {\n        subscriber.next(value);\n        subscriber.complete();\n    }\n}\nfunction dispatchError(arg) {\n    var err = arg.err, subscriber = arg.subscriber;\n    if (!subscriber.closed) {\n        subscriber.error(err);\n    }\n}\n//# sourceMappingURL=PromiseObservable.js.map"]},"metadata":{},"sourceType":"script"}