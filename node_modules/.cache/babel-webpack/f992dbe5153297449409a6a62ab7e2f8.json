{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\n\n\nfunction exhaustMap(project, resultSelector) {\n  return function (source) {\n    return source.lift(new SwitchFirstMapOperator(project, resultSelector));\n  };\n}\n\nexports.exhaustMap = exhaustMap;\n\nvar SwitchFirstMapOperator = function () {\n  function SwitchFirstMapOperator(project, resultSelector) {\n    this.project = project;\n    this.resultSelector = resultSelector;\n  }\n\n  SwitchFirstMapOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));\n  };\n\n  return SwitchFirstMapOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar SwitchFirstMapSubscriber = function (_super) {\n  __extends(SwitchFirstMapSubscriber, _super);\n\n  function SwitchFirstMapSubscriber(destination, project, resultSelector) {\n    _super.call(this, destination);\n\n    this.project = project;\n    this.resultSelector = resultSelector;\n    this.hasSubscription = false;\n    this.hasCompleted = false;\n    this.index = 0;\n  }\n\n  SwitchFirstMapSubscriber.prototype._next = function (value) {\n    if (!this.hasSubscription) {\n      this.tryNext(value);\n    }\n  };\n\n  SwitchFirstMapSubscriber.prototype.tryNext = function (value) {\n    var index = this.index++;\n    var destination = this.destination;\n\n    try {\n      var result = this.project(value, index);\n      this.hasSubscription = true;\n      this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n    } catch (err) {\n      destination.error(err);\n    }\n  };\n\n  SwitchFirstMapSubscriber.prototype._complete = function () {\n    this.hasCompleted = true;\n\n    if (!this.hasSubscription) {\n      this.destination.complete();\n    }\n  };\n\n  SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    var _a = this,\n        resultSelector = _a.resultSelector,\n        destination = _a.destination;\n\n    if (resultSelector) {\n      this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      destination.next(innerValue);\n    }\n  };\n\n  SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n    var _a = this,\n        resultSelector = _a.resultSelector,\n        destination = _a.destination;\n\n    try {\n      var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n      destination.next(result);\n    } catch (err) {\n      destination.error(err);\n    }\n  };\n\n  SwitchFirstMapSubscriber.prototype.notifyError = function (err) {\n    this.destination.error(err);\n  };\n\n  SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {\n    this.remove(innerSub);\n    this.hasSubscription = false;\n\n    if (this.hasCompleted) {\n      this.destination.complete();\n    }\n  };\n\n  return SwitchFirstMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber); //# sourceMappingURL=exhaustMap.js.map","map":{"version":3,"sources":["/Users/nguyenlong/ProjectCompany/2nMart/websiteclient-2nmart.vn/node_modules/ng5-slider/node_modules/rxjs/operators/exhaustMap.js"],"names":["__extends","d","b","p","hasOwnProperty","__","constructor","prototype","Object","create","OuterSubscriber_1","require","subscribeToResult_1","exhaustMap","project","resultSelector","source","lift","SwitchFirstMapOperator","exports","call","subscriber","subscribe","SwitchFirstMapSubscriber","_super","destination","hasSubscription","hasCompleted","index","_next","value","tryNext","result","add","subscribeToResult","err","error","_complete","complete","notifyNext","outerValue","innerValue","outerIndex","innerIndex","innerSub","_a","trySelectResult","next","notifyError","notifyComplete","remove","OuterSubscriber"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\nfunction exhaustMap(project, resultSelector) {\n    return function (source) { return source.lift(new SwitchFirstMapOperator(project, resultSelector)); };\n}\nexports.exhaustMap = exhaustMap;\nvar SwitchFirstMapOperator = (function () {\n    function SwitchFirstMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchFirstMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchFirstMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchFirstMapSubscriber = (function (_super) {\n    __extends(SwitchFirstMapSubscriber, _super);\n    function SwitchFirstMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.hasSubscription = false;\n        this.hasCompleted = false;\n        this.index = 0;\n    }\n    SwitchFirstMapSubscriber.prototype._next = function (value) {\n        if (!this.hasSubscription) {\n            this.tryNext(value);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {\n        var index = this.index++;\n        var destination = this.destination;\n        try {\n            var result = this.project(value, index);\n            this.hasSubscription = true;\n            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (!this.hasSubscription) {\n            this.destination.complete();\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        try {\n            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            destination.next(result);\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.hasSubscription = false;\n        if (this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return SwitchFirstMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=exhaustMap.js.map"]},"metadata":{},"sourceType":"script"}