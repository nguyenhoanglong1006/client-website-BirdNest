{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Buffers the source Observable values until `closingNotifier` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when another Observable emits.</span>\n *\n * <img src=\"./img/buffer.png\" width=\"100%\">\n *\n * Buffers the incoming Observable values until the given `closingNotifier`\n * Observable emits a value, at which point it emits the buffer on the output\n * Observable and starts a new buffer internally, awaiting the next time\n * `closingNotifier` emits.\n *\n * @example <caption>On every click, emit array of most recent interval events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var buffered = interval.buffer(clicks);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link window}\n *\n * @param {Observable<any>} closingNotifier An Observable that signals the\n * buffer to be emitted on the output Observable.\n * @return {Observable<T[]>} An Observable of buffers, which are arrays of\n * values.\n * @method buffer\n * @owner Observable\n */\n\n\nfunction buffer(closingNotifier) {\n  return function bufferOperatorFunction(source) {\n    return source.lift(new BufferOperator(closingNotifier));\n  };\n}\n\nexports.buffer = buffer;\n\nvar BufferOperator = function () {\n  function BufferOperator(closingNotifier) {\n    this.closingNotifier = closingNotifier;\n  }\n\n  BufferOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));\n  };\n\n  return BufferOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar BufferSubscriber = function (_super) {\n  __extends(BufferSubscriber, _super);\n\n  function BufferSubscriber(destination, closingNotifier) {\n    _super.call(this, destination);\n\n    this.buffer = [];\n    this.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));\n  }\n\n  BufferSubscriber.prototype._next = function (value) {\n    this.buffer.push(value);\n  };\n\n  BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    var buffer = this.buffer;\n    this.buffer = [];\n    this.destination.next(buffer);\n  };\n\n  return BufferSubscriber;\n}(OuterSubscriber_1.OuterSubscriber); //# sourceMappingURL=buffer.js.map","map":{"version":3,"sources":["/Users/nguyenlong/Project/BirdNest/client-website-BirdNest/node_modules/ng5-slider/node_modules/rxjs/operators/buffer.js"],"names":["__extends","d","b","p","hasOwnProperty","__","constructor","prototype","Object","create","OuterSubscriber_1","require","subscribeToResult_1","buffer","closingNotifier","bufferOperatorFunction","source","lift","BufferOperator","exports","call","subscriber","subscribe","BufferSubscriber","_super","destination","add","subscribeToResult","_next","value","push","notifyNext","outerValue","innerValue","outerIndex","innerIndex","innerSub","next","OuterSubscriber"],"mappings":"AAAA;;AACA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA4B,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AACxD,OAAK,IAAIC,CAAT,IAAcD,CAAd,EAAiB,IAAIA,CAAC,CAACE,cAAF,CAAiBD,CAAjB,CAAJ,EAAyBF,CAAC,CAACE,CAAD,CAAD,GAAOD,CAAC,CAACC,CAAD,CAAR;;AAC1C,WAASE,EAAT,GAAc;AAAE,SAAKC,WAAL,GAAmBL,CAAnB;AAAuB;;AACvCA,EAAAA,CAAC,CAACM,SAAF,GAAcL,CAAC,KAAK,IAAN,GAAaM,MAAM,CAACC,MAAP,CAAcP,CAAd,CAAb,IAAiCG,EAAE,CAACE,SAAH,GAAeL,CAAC,CAACK,SAAjB,EAA4B,IAAIF,EAAJ,EAA7D,CAAd;AACH,CAJD;;AAKA,IAAIK,iBAAiB,GAAGC,OAAO,CAAC,oBAAD,CAA/B;;AACA,IAAIC,mBAAmB,GAAGD,OAAO,CAAC,2BAAD,CAAjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,MAAT,CAAgBC,eAAhB,EAAiC;AAC7B,SAAO,SAASC,sBAAT,CAAgCC,MAAhC,EAAwC;AAC3C,WAAOA,MAAM,CAACC,IAAP,CAAY,IAAIC,cAAJ,CAAmBJ,eAAnB,CAAZ,CAAP;AACH,GAFD;AAGH;;AACDK,OAAO,CAACN,MAAR,GAAiBA,MAAjB;;AACA,IAAIK,cAAc,GAAI,YAAY;AAC9B,WAASA,cAAT,CAAwBJ,eAAxB,EAAyC;AACrC,SAAKA,eAAL,GAAuBA,eAAvB;AACH;;AACDI,EAAAA,cAAc,CAACX,SAAf,CAAyBa,IAAzB,GAAgC,UAAUC,UAAV,EAAsBL,MAAtB,EAA8B;AAC1D,WAAOA,MAAM,CAACM,SAAP,CAAiB,IAAIC,gBAAJ,CAAqBF,UAArB,EAAiC,KAAKP,eAAtC,CAAjB,CAAP;AACH,GAFD;;AAGA,SAAOI,cAAP;AACH,CARqB,EAAtB;AASA;AACA;AACA;AACA;AACA;;;AACA,IAAIK,gBAAgB,GAAI,UAAUC,MAAV,EAAkB;AACtCxB,EAAAA,SAAS,CAACuB,gBAAD,EAAmBC,MAAnB,CAAT;;AACA,WAASD,gBAAT,CAA0BE,WAA1B,EAAuCX,eAAvC,EAAwD;AACpDU,IAAAA,MAAM,CAACJ,IAAP,CAAY,IAAZ,EAAkBK,WAAlB;;AACA,SAAKZ,MAAL,GAAc,EAAd;AACA,SAAKa,GAAL,CAASd,mBAAmB,CAACe,iBAApB,CAAsC,IAAtC,EAA4Cb,eAA5C,CAAT;AACH;;AACDS,EAAAA,gBAAgB,CAAChB,SAAjB,CAA2BqB,KAA3B,GAAmC,UAAUC,KAAV,EAAiB;AAChD,SAAKhB,MAAL,CAAYiB,IAAZ,CAAiBD,KAAjB;AACH,GAFD;;AAGAN,EAAAA,gBAAgB,CAAChB,SAAjB,CAA2BwB,UAA3B,GAAwC,UAAUC,UAAV,EAAsBC,UAAtB,EAAkCC,UAAlC,EAA8CC,UAA9C,EAA0DC,QAA1D,EAAoE;AACxG,QAAIvB,MAAM,GAAG,KAAKA,MAAlB;AACA,SAAKA,MAAL,GAAc,EAAd;AACA,SAAKY,WAAL,CAAiBY,IAAjB,CAAsBxB,MAAtB;AACH,GAJD;;AAKA,SAAOU,gBAAP;AACH,CAhBuB,CAgBtBb,iBAAiB,CAAC4B,eAhBI,CAAxB,C,CAiBA","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Buffers the source Observable values until `closingNotifier` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when another Observable emits.</span>\n *\n * <img src=\"./img/buffer.png\" width=\"100%\">\n *\n * Buffers the incoming Observable values until the given `closingNotifier`\n * Observable emits a value, at which point it emits the buffer on the output\n * Observable and starts a new buffer internally, awaiting the next time\n * `closingNotifier` emits.\n *\n * @example <caption>On every click, emit array of most recent interval events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var buffered = interval.buffer(clicks);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link window}\n *\n * @param {Observable<any>} closingNotifier An Observable that signals the\n * buffer to be emitted on the output Observable.\n * @return {Observable<T[]>} An Observable of buffers, which are arrays of\n * values.\n * @method buffer\n * @owner Observable\n */\nfunction buffer(closingNotifier) {\n    return function bufferOperatorFunction(source) {\n        return source.lift(new BufferOperator(closingNotifier));\n    };\n}\nexports.buffer = buffer;\nvar BufferOperator = (function () {\n    function BufferOperator(closingNotifier) {\n        this.closingNotifier = closingNotifier;\n    }\n    BufferOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));\n    };\n    return BufferOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferSubscriber = (function (_super) {\n    __extends(BufferSubscriber, _super);\n    function BufferSubscriber(destination, closingNotifier) {\n        _super.call(this, destination);\n        this.buffer = [];\n        this.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));\n    }\n    BufferSubscriber.prototype._next = function (value) {\n        this.buffer.push(value);\n    };\n    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var buffer = this.buffer;\n        this.buffer = [];\n        this.destination.next(buffer);\n    };\n    return BufferSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=buffer.js.map"]},"metadata":{},"sourceType":"script"}